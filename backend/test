
frontend/app/component/email-management.tsx
"use client";

import React, { useState } from "react";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Loader } from "@/components/loader";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { TriangleAlert, Trash2, Pencil, Plus } from "lucide-react";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
// Update the import path to the correct location of use-emails.ts
import { useEmails } from "@/hooks/use-emails";
import { emailSchema, type EmailEntry } from "@/lib/schema";
import { z } from "zod";

const EmailManagement = () => {
  const { emails, isLoading, error, addEmail, updateEmail, deleteEmail } = useEmails();

  const [showModal, setShowModal] = useState(false);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [emailToDelete, setEmailToDelete] = useState<string | null>(null);
  const [currentEmail, setCurrentEmail] = useState<EmailEntry | null>(null);

  const form = useForm<z.infer<typeof emailSchema>>({
    resolver: zodResolver(emailSchema),
    defaultValues: {
      name: "",
      email: "",
    },
  });

  const handleAddClick = () => {
    setCurrentEmail(null);
    form.reset({ name: "", email: "" });
    setShowModal(true);
  };

  const handleEditClick = (email: EmailEntry) => {
    setCurrentEmail(email);
    form.reset({ name: email.name, email: email.email });
    setShowModal(true);
  };

  const handleDeleteClick = (_id: string) => {
    setEmailToDelete(_id);
    setShowDeleteDialog(true);
  };

  const handleConfirmDelete = async () => {
    if (emailToDelete) {
      await deleteEmail(emailToDelete);
    }
    setShowDeleteDialog(false);
    setEmailToDelete(null);
  };

  const handleSubmit = async (values: z.infer<typeof emailSchema>) => {
    if (currentEmail) {
      // Editing an existing email
      await updateEmail(currentEmail._id, values);
    } else {
      // Adding a new email
      // Check for duplicate emails on the frontend
      const isDuplicate = emails.some(entry => entry.email === values.email);

      if (isDuplicate) {
        // Use setError to display the error message on the email field
        form.setError("email", {
          type: "manual",
          message: "This email is already added.",
        });
        return; // Stop the function here
      }

      await addEmail(values);
    }
    setShowModal(false);
  };

  return (
    <div className="container mx-auto p-4">
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-2xl font-bold">Email Management</h3>
        <Button onClick={handleAddClick} className="flex items-center gap-2">
          <Plus className="h-4 w-4" /> Add Email
        </Button>
      </div>

      {error && (
        <Alert variant="destructive" className="mb-4">
          <TriangleAlert className="h-4 w-4" />
          <AlertTitle>Error</AlertTitle>
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      {isLoading ? (
        <Loader />
      ) : (
        <div className="rounded-md border">
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead className="w-[50px]">#</TableHead>
                <TableHead>Name</TableHead>
                <TableHead>Email</TableHead>
                <TableHead className="text-right">Actions</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {emails.length === 0 ? (
                <TableRow>
                  <TableCell colSpan={4} className="text-center">
                    No emails found.
                  </TableCell>
                </TableRow>
              ) : (
                emails.map((entry, index) => (
                  <TableRow key={entry._id}>
                    <TableCell>{index + 1}</TableCell>
                    <TableCell>{entry.name}</TableCell>
                    <TableCell>{entry.email}</TableCell>
                    <TableCell className="text-right">
                      <Button
                        variant="ghost"
                        size="sm"
                        className="text-yellow-500 hover:text-yellow-700"
                        onClick={() => handleEditClick(entry)}
                      >
                        <Pencil className="h-4 w-4" />
                      </Button>
                      <Button
                        variant="ghost"
                        size="sm"
                        className="text-red-500 hover:text-red-700 ml-2"
                        onClick={() => handleDeleteClick(entry._id)}
                      >
                        <Trash2 className="h-4 w-4" />
                      </Button>
                    </TableCell>
                  </TableRow>
                ))
              )}
            </TableBody>
          </Table>
        </div>
      )}

      {/* Modal for Adding & Editing Emails */}
      <Dialog open={showModal} onOpenChange={setShowModal}>
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle>
              {currentEmail ? "Edit Email" : "Add Email"}
            </DialogTitle>
          </DialogHeader>
          <Form {...form}>
            <form onSubmit={form.handleSubmit(handleSubmit)}>
              <FormField
                control={form.control}
                name="name"
                render={({ field }) => (
                  <FormItem className="mb-4">
                    <FormLabel>Name</FormLabel>
                    <FormControl>
                      <Input placeholder="Enter Name" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem className="mb-4">
                    <FormLabel>Email</FormLabel>
                    <FormControl>
                      <Input type="email" placeholder="Enter Email" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <DialogFooter className="mt-4">
                <Button type="submit">
                  {currentEmail ? "Update Email" : "Add Email"}
                </Button>
              </DialogFooter>
            </form>
          </Form>
        </DialogContent>
      </Dialog>
      
      {/* Custom Confirmation Dialog for Deleting */}
      <AlertDialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete the email entry.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={handleConfirmDelete}>Continue</AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
};

export default EmailManagement;











frontend/app/component/layout/header.tsx
// frontend/app/component/layout/header.tsx
import { useAuth } from "@/provider/auth-context";
import { Button } from "../ui/button";
import { Bell } from "lucide-react";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuTrigger,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuItem,
} from "../ui/dropdown-menu";
import { Avatar, AvatarImage, AvatarFallback } from "../ui/avatar";
import { Link, useNavigate } from "react-router";
import { BarChart3 } from "lucide-react";
import { memo } from "react";

interface HeaderProps {
  onProjectSelect?: (project: any) => void;
  selectedProject?: any;
}

// Memoize the Header component to prevent unnecessary re-renders
const HeaderComponent = memo(({ onProjectSelect, selectedProject }: HeaderProps) => {
  const navigate = useNavigate();
  const { user, logout } = useAuth();
  
  return (
    <div className="bg-background sticky top-0 z-40 border-b">
      <div className="flex h-14 items-center justify-between px-4 sm:px-6 lg:px-8 py-4">
        <div className="flex items-center">
          <BarChart3 className="h-6 w-6 text-blue-600 mr-2" />
          <h1 className="text-xl font-bold">Project Management Dashboard</h1>
        </div>
        
        <div className="flex items-center gap-4">
          <Button variant="ghost" size="icon">
            <Bell />
          </Button>
          
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <button className="rounded-full border p-1 w-8 h-8">
                <Avatar className="w-8 h-8">
                  <AvatarImage src={user?.profilePicture} alt={user?.name} />
                  <AvatarFallback className="bg-primary text-primary-foreground">
                    {user?.name?.charAt(0).toUpperCase()}
                  </AvatarFallback>
                </Avatar>
              </button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuLabel>My Account</DropdownMenuLabel>
              <DropdownMenuSeparator />
              <DropdownMenuItem>
                <Link to="/user/profile">Profile</Link>
              </DropdownMenuItem>
              <DropdownMenuSeparator />
              <DropdownMenuItem onClick={logout}>Log Out</DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      </div>
    </div>
  );
});

HeaderComponent.displayName = 'Header';

// Export the component with the name 'Header'
export { HeaderComponent as Header };








frontend/app/component/sidebar-component.tsx
import { cn } from "@/lib/utils";
import { useAuth } from "@/provider/auth-context";
import {
  CheckCircle2,
  ChevronsLeft,
  ChevronsRight,
  LayoutDashboard,
  ListCheck,
  LogOut,
  Settings,
  Users,
  Mail,
  Plus,
  Wrench,
  BarChart3
} from "lucide-react";
import { useState } from "react";
import { Link } from "react-router-dom";
import { Button } from "../ui/button";
import { ScrollArea } from "../ui/scroll-area";
import { SidebarNav } from "./sidebar-nav";

export const SidebarComponent = () => {
  const { user, logout } = useAuth();
  const [isCollapsed, setIsCollapsed] = useState(false);
  
  const navItems = [
    {
      title: "Dashboard",
      href: "/dashboard",
      icon: LayoutDashboard,
    },
    {
      title: "Create Project",
      href: "/projects",
      icon: Plus,
    },
    {
      title: "Create Stages",
      href: "/stages",
      icon: Plus,
    },
    {
      title: "Emails",
      href: "/emails",
      icon: Mail,
    },
    {
      title: "User Profile",
      href: "/user/profile",
      icon: Users,
    },
    {
      title: "Settings",
      href: "/settings",
      icon: Settings,
    },
  ];

  return (
    <div
      className={cn(
        "flex flex-col border-r bg-sidebar transition-all duration-300",
        isCollapsed ? "w-16 md:w-[80px]" : "w-16 md:w-[240px]"
      )}
    >
      <div className="flex h-14 items-center border-b px-4 mb-4">
        <Link to="/dashboard" className="flex items-center">
          {!isCollapsed && (
            <div className="flex items-center gap-2">
              <BarChart3 className="size-6 text-blue-600" />
              <span className="font-semibold text-lg hidden md:block">
                TaskHub
              </span>
            </div>
          )}
          {isCollapsed && <BarChart3 className="size-6 text-blue-600" />}
        </Link>
        <Button
          variant={"ghost"}
          size="icon"
          className="ml-auto hidden md:block"
          onClick={() => setIsCollapsed(!isCollapsed)}
        >
          {isCollapsed ? (
            <ChevronsRight className="size-4" />
          ) : (
            <ChevronsLeft className="size-4" />
          )}
        </Button>
      </div>
      <ScrollArea className="flex-1 px-3 py-2">
        <SidebarNav
          items={navItems}
          isCollapsed={isCollapsed}
          className={cn(isCollapsed && "items-center space-y-2")}
        />
      </ScrollArea>
      <div className="mt-auto px-3 py-2">
        <Button
          variant={"ghost"}
          size={isCollapsed ? "icon" : "default"}
          className="w-full"
          onClick={logout}
        >
          <LogOut className={cn("size-4 mr-2", isCollapsed && "mr-0")} />
          {!isCollapsed && <span className="hidden md:block">Logout</span>}
        </Button>
      </div>
    </div>
  );
};







frontend/app/component/sidbar-nav.tsx

import { cn } from "@/lib/utils";
import type { LucideIcon } from "lucide-react";
import { Button } from "../ui/button";
import { useLocation, useNavigate } from "react-router";

interface SidebarNavProps extends React.HtmlHTMLAttributes<HTMLElement> {
  items: {
    title: string;
    href: string;
    icon: LucideIcon;
  }[];
  isCollapsed: boolean;
  className?: string;
}

export const SidebarNav = ({
  items,
  isCollapsed,
  className,
  ...props
}: SidebarNavProps) => {
  const location = useLocation();
  const navigate = useNavigate();

  return (
    <nav className={cn("flex flex-col gap-y-2", className)} {...props}>
      {items.map((el) => {
        const Icon = el.icon;
        const isActive = location.pathname === el.href;
        const handleClick = () => {
          navigate(el.href);
        };

        return (
          <Button
            key={el.href}
            variant={isActive ? "outline" : "ghost"}
            className={cn(
              "justify-start",
              isActive && "bg-blue-800/20 text-blue-600 font-medium"
            )}
            onClick={handleClick}
          >
            <Icon className="mr-2 size-4" />
            {isCollapsed ? (
              <span className="sr-only">{el.title}</span>
            ) : (
              el.title
            )}
          </Button>
        );
      })}
    </nav>
  );
};





frontend/app/component/projects/hooks/useProjectFilters.tsx
// frontend/app/components/projects/hooks/useProjectFilters.tsx

// frontend/app/component/projects/hooks/useProjectFilters.tsx
import { useMemo } from 'react';
import { type ProjectEntry } from '@/lib/schema';

interface UseProjectFiltersProps {
  projects: ProjectEntry[];
  sortBy: 'newest' | 'oldest';
  statusFilter: string;
  searchTerm: string;
  dateRange: {
    startDate: string | undefined;
    endDate: string | undefined;
  };
}

export const useProjectFilters = ({
  projects,
  sortBy,
  statusFilter,
  searchTerm,
  dateRange
}: UseProjectFiltersProps) => {
  const filteredAndSortedProjects = useMemo(() => {
    console.log("useProjectFilters called with:", {
      projectsCount: projects.length,
      statusFilter,
      searchTerm,
      dateRange
    });
    
    let result = [...projects];
    
    // Apply search filter
    if (searchTerm) {
      const term = searchTerm.toLowerCase();
      result = result.filter(project =>
        project.project_name.toLowerCase().includes(term) ||
        (project.description && project.description.toLowerCase().includes(term)) ||
        (project.status && project.status.toLowerCase().includes(term))
      );
    }
    
    // Apply status filter (case insensitive)
    if (statusFilter !== 'all') {
      console.log(`Filtering by status: ${statusFilter}`);
      console.log(`Projects before status filter: ${result.length}`);
      result = result.filter(project => {
        // Compare in lowercase for case insensitivity
        return project.status && project.status.toLowerCase() === statusFilter.toLowerCase();
      });
      console.log(`Projects after status filter: ${result.length}`);
    }
    
    // Apply date range filter
    if (dateRange.startDate && dateRange.endDate) {
      const startDate = new Date(dateRange.startDate);
      const endDate = new Date(dateRange.endDate);
      result = result.filter(project => {
        const projectDate = new Date(project.created_at);
        return projectDate >= startDate && projectDate <= endDate;
      });
    }
    
    // Apply sorting
    result.sort((a, b) => {
      const dateA = new Date(a.created_at).getTime();
      const dateB = new Date(b.created_at).getTime();
      if (sortBy === 'newest') {
        return dateB - dateA; // Most recent first
      } else {
        return dateA - dateB; // Oldest first
      }
    });
    
    console.log("Final filtered projects:", result);
    return result;
  }, [projects, statusFilter, sortBy, searchTerm, dateRange]);
  
  return {
    filteredAndSortedProjects,
    hasProjects: projects.length > 0,
    hasFilteredProjects: filteredAndSortedProjects.length > 0
  };
};





frontend/app/component/projects/ConnectionForm.tsx
// frontend/app/components/projects/ConnectionForm.tsx
// frontend/app/components/projects/ConnectionForm.tsx
import React, { useState } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter, DialogDescription } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { AlertCircle } from "lucide-react";
import { type ProjectStageEntry, type StageConnectionEntry } from "@/lib/schema";
import { ArrowRight } from "lucide-react";

interface ConnectionFormProps {
  stages: ProjectStageEntry[];
  connections: StageConnectionEntry[];
  onSubmit: (fromStageId: string, toStageId: string) => void;
  onCancel: () => void;
}

export const ConnectionForm: React.FC<ConnectionFormProps> = ({
  stages,
  connections,
  onSubmit,
  onCancel
}) => {
  const [fromStageId, setFromStageId] = useState<string>('');
  const [toStageId, setToStageId] = useState<string>('');
  const [error, setError] = useState<string | null>(null);
  
  const handleSubmit = () => {
    if (!fromStageId || !toStageId) {
      setError("Please select both source and destination stages");
      return;
    }
    
    if (fromStageId === toStageId) {
      setError("Source and destination stages cannot be the same");
      return;
    }
    
    // Check if connection already exists
    const connectionExists = connections.some(conn => 
      conn.from_stage._id === fromStageId && conn.to_stage._id === toStageId
    );
    
    if (connectionExists) {
      setError("This connection already exists");
      return;
    }
    
    onSubmit(fromStageId, toStageId);
  };
  
  return (
    <Dialog open={true} onOpenChange={onCancel}>
      <DialogContent className="sm:max-w-[500px] max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>Connect Stages</DialogTitle>
          <DialogDescription>
            Create a connection between two stages in your project.
          </DialogDescription>
        </DialogHeader>
        
        <div className="space-y-4">
          {error && (
            <Alert variant="destructive">
              <AlertCircle className="h-4 w-4" />
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}
          
          <div className="flex items-center space-x-4">
            <div className="flex-1 space-y-2">
              <label className="text-sm font-medium">From Stage</label>
              <Select value={fromStageId} onValueChange={setFromStageId}>
                <SelectTrigger className="h-auto py-2">
                  <SelectValue placeholder="Select source stage" />
                </SelectTrigger>
                <SelectContent>
                  {stages.map(stage => (
                    <SelectItem key={`from-${stage._id}`} value={stage._id} className="whitespace-normal">
                      <div className="max-w-xs">
                        <div className="whitespace-normal break-words">
                          {stage.stage.stage_name}
                        </div>
                      </div>
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            
            <div className="flex items-center justify-center mt-6">
              <ArrowRight className="h-6 w-6 text-muted-foreground" />
            </div>
            
            <div className="flex-1 space-y-2">
              <label className="text-sm font-medium">To Stage</label>
              <Select value={toStageId} onValueChange={setToStageId}>
                <SelectTrigger className="h-auto py-2">
                  <SelectValue placeholder="Select destination stage" />
                </SelectTrigger>
                <SelectContent>
                  {stages.map(stage => (
                    <SelectItem key={`to-${stage._id}`} value={stage._id} className="whitespace-normal">
                      <div className="max-w-xs">
                        <div className="whitespace-normal break-words">
                          {stage.stage.stage_name}
                        </div>
                      </div>
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
          </div>
        </div>
        
        <DialogFooter className="mt-6">
          <Button type="button" variant="outline" onClick={onCancel}>
            Cancel
          </Button>
          <Button onClick={handleSubmit}>
            Create Connection
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};







frontend/app/component/projects/ConnectionLine.tsx
// frontend/app/components/projects/ConnectionLine.tsx
import React from "react";
import { X } from "lucide-react";
import { Button } from "@/components/ui/button";
import { type StageConnectionEntry } from "@/lib/schema";

interface ConnectionLineProps {
  connection: StageConnectionEntry;
  onRemove: (connectionId: string) => void;
}

export const ConnectionLine: React.FC<ConnectionLineProps> = ({ connection, onRemove }) => {
  return (
    <div className="absolute top-0 left-0 w-full h-full pointer-events-none z-20">
      {/* Remove connection button */}
      <Button
        variant="outline"
        size="sm"
        className="absolute pointer-events-auto z-30 bg-white shadow-md"
        style={{
          left: '50%',
          top: '50%',
          transform: 'translate(-50%, -50%)'
        }}
        onClick={(e) => {
          e.stopPropagation();
          onRemove(connection._id);
        }}
      >
        <X className="h-3 w-3" />
      </Button>
    </div>
  );
};







frontend/app/component/projects/project-card.tsx
// frontend/app/components/projects/project-card.tsx

// frontend/app/components/projects/projects-card.tsx
import React from 'react';
import { ProjectCard } from './project-card';
import { type ProjectEntry } from '@/lib/schema';

interface ProjectCardsProps {
  projects: ProjectEntry[];
  onEdit: (project: ProjectEntry) => void;
  onDelete: (id: string) => void;
  onProjectClick: (id: string) => void;
}

export const ProjectCards: React.FC<ProjectCardsProps> = ({ 
  projects, 
  onEdit, 
  onDelete,
  onProjectClick
}) => {
  if (projects.length === 0) {
    return (
      <div className="text-center py-12">
        <p className="text-muted-foreground">No projects found.</p>
      </div>
    );
  }
  
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
      {projects.map((project) => (
        <ProjectCard 
          key={project._id} 
          project={project} 
          onEdit={onEdit} 
          onDelete={onDelete}
          onProjectClick={onProjectClick}
        />
      ))}
    </div>
  );
};










frontend/app/component/projects/project-management.tsx
// frontend/app/components/projects/project-management.tsx
// frontend/app/component/projects/project-management.tsx
"use client";
import React, { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Plus, Grid, List } from "lucide-react";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { TriangleAlert } from "lucide-react";
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle } from "@/components/ui/alert-dialog";
import { useProjects } from "@/hooks/use-projects";
import { projectSchema, type ProjectEntry } from "@/lib/schema";
import { z } from "zod";
import { ProjectFilterControls } from "./ProjectFilterControls";
import { ProjectTable } from "./ProjectTable";
import { ProjectCards } from "./projects-card";
import { ProjectForm } from "./ProjectForm";
import { useProjectFilters } from "./hooks/useProjectFilters";
import { useNavigate, useSearchParams } from "react-router-dom";

const ProjectManagement = () => {
  const { projects, isLoading, error, createProject, updateProject, deleteProject } = useProjects();
  const [showForm, setShowForm] = useState(false);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [projectToDelete, setProjectToDelete] = useState<string | null>(null);
  const [currentProject, setCurrentProject] = useState<ProjectEntry | null>(null);
  const [sortBy, setSortBy] = useState<'newest' | 'oldest'>('newest');
  const [statusFilter, setStatusFilter] = useState<string>('all');
  const [searchTerm, setSearchTerm] = useState<string>('');
  const [dateRange, setDateRange] = useState<{ startDate: Date | undefined; endDate: Date | undefined; }>({ startDate: undefined, endDate: undefined });
  const [viewMode, setViewMode] = useState<'table' | 'cards'>('table');
  
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  
  // Get filter from URL parameters
  useEffect(() => {
    const filterParam = searchParams.get('filter');
    console.log("Filter param from URL:", filterParam); // Debug log
    
    if (filterParam) {
      if (filterParam.toLowerCase() === 'all') {
        setStatusFilter('all');
      } else if (['ongoing', 'completed', 'pending', 'archived'].includes(filterParam.toLowerCase())) {
        // Convert to proper case (first letter capitalized)
        const properCaseFilter = filterParam.charAt(0).toUpperCase() + filterParam.slice(1);
        console.log("Setting status filter to:", properCaseFilter); // Debug log
        setStatusFilter(properCaseFilter);
      }
    }
  }, [searchParams]);
  
  const { filteredAndSortedProjects, hasProjects, hasFilteredProjects } = useProjectFilters({
    projects,
    sortBy,
    statusFilter,
    searchTerm,
    dateRange: {
      startDate: dateRange.startDate ? dateRange.startDate.toISOString().split('T')[0] : undefined,
      endDate: dateRange.endDate ? dateRange.endDate.toISOString().split('T')[0] : undefined
    }
  });
  
  // Debug logs
  useEffect(() => {
    console.log("Current status filter:", statusFilter);
    console.log("Filtered projects:", filteredAndSortedProjects);
    console.log("All projects:", projects);
    console.log("Projects with ongoing status:", projects.filter(p => p.status === 'Ongoing'));
    console.log("Projects with completed status:", projects.filter(p => p.status === 'Completed'));
    console.log("Projects with pending status:", projects.filter(p => p.status === 'Pending'));
  }, [statusFilter, filteredAndSortedProjects, projects]);
  
  const handleAddClick = () => {
    setCurrentProject(null);
    setShowForm(true);
  };
  
  const handleEditClick = (project: ProjectEntry) => {
    setCurrentProject(project);
    setShowForm(true);
  };
  
  const handleDeleteClick = (_id: string) => {
    setProjectToDelete(_id);
    setShowDeleteDialog(true);
  };
  
  const handleConfirmDelete = async () => {
    if (projectToDelete) {
      await deleteProject(projectToDelete);
    }
    setShowDeleteDialog(false);
    setProjectToDelete(null);
  };
  
  const handleSubmit = async (values: z.infer<typeof projectSchema>) => {
    if (currentProject) {
      await updateProject(currentProject._id, values);
    } else {
      await createProject(values);
    }
    setShowForm(false);
  };
  
  // Handle sort toggle
  const toggleSort = () => {
    setSortBy(sortBy === 'newest' ? 'oldest' : 'newest');
  };
  
  // Handle project click
  const handleProjectClick = (projectId: string) => {
    navigate(`/projects/${projectId}`);
  };
  
  // Handle status filter change
  const handleStatusFilterChange = (status: string) => {
    console.log("Status filter changed to:", status); // Debug log
    setStatusFilter(status);
    // Update URL to reflect the current filter
    const params = new URLSearchParams(searchParams);
    if (status === 'all') {
      params.delete('filter');
    } else {
      params.set('filter', status.toLowerCase());
    }
    console.log("Updating URL to:", `/projects?${params.toString()}`); // Debug log
    navigate(`/projects?${params.toString()}`, { replace: true });
  };
  
  return (
    <div className="container mx-auto p-4 pt-0">
      {/* Header with no bottom margin */}
      <div className="flex items-center justify-between mb-0">
        <h3 className="text-xl font-bold">Project Management</h3>
        <div className="flex items-center gap-2">
          <Button onClick={handleAddClick} className="flex items-center gap-1 text-sm py-1 h-8">
            <Plus className="h-3 w-3" />
            Create Project
          </Button>
          <Button variant="outline" size="sm" onClick={() => setViewMode(viewMode === 'table' ? 'cards' : 'table')} className="flex items-center gap-1">
            {viewMode === 'table' ? (
              <>
                <Grid className="h-4 w-4" />
                Cards
              </>
            ) : (
              <>
                <List className="h-4 w-4" />
                Table
              </>
            )}
          </Button>
        </div>
      </div>
      
      {/* Filter Controls */}
      <ProjectFilterControls
        sortBy={sortBy}
        statusFilter={statusFilter}
        searchTerm={searchTerm}
        dateRange={dateRange}
        onSortChange={setSortBy}
        onStatusFilterChange={handleStatusFilterChange}
        onSearchChange={setSearchTerm}
        onDateRangeChange={setDateRange}
      />
      
      {error && (
        <Alert variant="destructive" className="mb-2">
          <TriangleAlert className="h-4 w-4" />
          <AlertTitle>Error</AlertTitle>
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}
      
      {/* Scrollable content container */}
      <div className="overflow-y-auto max-h-[calc(100vh-200px)]">
        {isLoading ? (
          <div className="flex items-center justify-center h-32">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
          </div>
        ) : (
          <>
            {viewMode === 'table' ? (
              <ProjectTable
                projects={filteredAndSortedProjects}
                onEdit={handleEditClick}
                onDelete={handleDeleteClick}
                onProjectClick={handleProjectClick}
                onSortToggle={toggleSort}
                sortBy={sortBy}
                isLoading={isLoading}
                hasProjects={hasProjects}
                hasFilteredProjects={hasFilteredProjects}
              />
            ) : (
              <ProjectCards
                projects={filteredAndSortedProjects}
                onEdit={handleEditClick}
                onDelete={handleDeleteClick}
                onProjectClick={handleProjectClick}
              />
            )}
          </>
        )}
      </div>
      
      {/* Form for Adding & Editing Projects */}
      <ProjectForm
        isOpen={showForm}
        onClose={() => setShowForm(false)}
        project={currentProject}
        onSubmit={handleSubmit}
      />
      
      {/* Custom Confirmation Dialog for Deleting */}
      <AlertDialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete the project.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={handleConfirmDelete}>Continue</AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
};

export default ProjectManagement;












frontend/app/component/projects/ProjectDetail.tsx
// frontend/app/components/projects/ProjectDetail.tsx
import React, { useState } from "react";
import { useParams, useNavigate } from "react-router-dom";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { ArrowLeft, Plus, Calendar, CheckCircle, Circle, Trash2, Edit } from "lucide-react";
import { format } from "date-fns";
import { useProjectDetail } from "@/hooks/useProjectDetail";
import { ProjectStageForm } from "./ProjectStageForm";
import { ConnectionForm } from "./ConnectionForm";
import { ProjectStageCard } from "./ProjectStageCard";
import { ProjectStageTable } from "./ProjectStageTable";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { AlertCircle } from "lucide-react";

export const ProjectDetail: React.FC = () => {
  const { projectId } = useParams<{ projectId: string }>();
  const navigate = useNavigate();
  
  const [showStageForm, setShowStageForm] = useState(false);
  const [showConnectionForm, setShowConnectionForm] = useState(false);
  const [viewMode, setViewMode] = useState<'cards' | 'table'>('cards');
  const [editingStage, setEditingStage] = useState<string | null>(null);
  const [preSelectedStageId, setPreSelectedStageId] = useState<string | null>(null);
  
  const {
    project,
    stages,
    connections,
    availableStages,
    isLoading,
    error,
    addStageToProject,
    updateProjectStage,
    deleteProjectStage,
    createStageConnection
  } = useProjectDetail(projectId || null);
  
  const handleAddStage = (stageId: string, status: 'Ongoing' | 'Completed', startDate?: string, completionDate?: string) => {
    addStageToProject(stageId, status, startDate, completionDate);
    setShowStageForm(false);
    setPreSelectedStageId(null);
  };
  
  const handleStageClick = (stageId: string) => {
    setPreSelectedStageId(stageId);
    setShowStageForm(true);
  };
  
  const handleUpdateStage = (stageId: string, status: 'Ongoing' | 'Completed', startDate?: string, completionDate?: string) => {
    updateProjectStage(stageId, status, startDate, completionDate);
    setEditingStage(null);
  };
  
  const handleCreateConnection = (fromStageId: string, toStageId: string) => {
    createStageConnection(fromStageId, toStageId);
    setShowConnectionForm(false);
  };
  
  const handleMarkComplete = (stageId: string) => {
    const stage = stages.find(s => s._id === stageId);
    if (stage) {
      // Show completion date picker
      setEditingStage(stageId);
    }
  };
  
  const formatDisplayDate = (dateString?: string) => {
    if (!dateString) return "Not set";
    try {
      return format(new Date(dateString), "MMM dd, yyyy");
    } catch (error) {
      return dateString;
    }
  };
  
  const getStatusColor = (status: string) => {
    switch (status) {
      case 'Ongoing': return 'bg-blue-100 text-blue-800';
      case 'Completed': return 'bg-green-100 text-green-800';
      default: return 'bg-gray-100 text-gray-800';
    }
  };
  
  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
      </div>
    );
  }
  
  if (error || !project) {
    return (
      <div className="container mx-auto p-4">
        <Alert variant="destructive">
          <AlertCircle className="h-4 w-4" />
          <AlertDescription>
            {error || "Project not found"}
          </AlertDescription>
        </Alert>
        <Button className="mt-4" onClick={() => navigate("/projects")}>
          <ArrowLeft className="mr-2 h-4 w-4" /> Back to Projects
        </Button>
      </div>
    );
  }
  
  return (
    <div className="container mx-auto p-4">
      {/* Header */}
      <div className="flex items-center justify-between mb-6">
        <div className="flex items-center">
          <Button variant="ghost" onClick={() => navigate("/projects")} className="mr-4">
            <ArrowLeft className="h-4 w-4" />
          </Button>
          <div>
            <h1 className="text-2xl font-bold">{project.project_name}</h1>
            <div className="flex items-center mt-1">
              <Badge className={getStatusColor(project.status || '')}>
                {project.status}
              </Badge>
              <span className="text-sm text-muted-foreground ml-2">
                Created: {formatDisplayDate(project.created_at)}
              </span>
            </div>
          </div>
        </div>
        
        <div className="flex gap-2">
          <Button 
            variant="outline" 
            onClick={() => setViewMode(viewMode === 'cards' ? 'table' : 'cards')}
          >
            {viewMode === 'cards' ? 'Table View' : 'Card View'}
          </Button>
          <Button onClick={() => {
            setShowStageForm(true);
            setPreSelectedStageId(null);
          }}>
            <Plus className="mr-2 h-4 w-4" /> Add Stage
          </Button>
          <Button 
            variant="outline" 
            onClick={() => setShowConnectionForm(true)}
            disabled={stages.length < 2}
          >
            Connect Stages
          </Button>
        </div>
      </div>
      
      {/* Available Stages */}
      {availableStages.length > 0 && (
        <Card className="mb-6">
          <CardHeader>
            <CardTitle className="text-lg">Available Stages</CardTitle>
            <p className="text-sm text-muted-foreground">Click on a stage to add it to the project</p>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-3">
              {availableStages.map(stage => (
                <div 
                  key={stage._id}
                  className="p-3 border rounded-lg cursor-pointer hover:bg-muted transition-colors hover:shadow-sm"
                  onClick={() => handleStageClick(stage._id)}
                >
                  <div className="font-medium line-clamp-2">{stage.stage_name}</div>
                  {stage.description && (
                    <div className="text-sm text-muted-foreground mt-1 line-clamp-2">
                      {stage.description}
                    </div>
                  )}
                </div>
              ))}
            </div>
          </CardContent>
        </Card>
      )}
      
      {/* Project Stages */}
      <Card>
        <CardHeader>
          <CardTitle className="text-lg flex items-center">
            Project Stages
            <Badge variant="secondary" className="ml-2">
              {stages.length} {stages.length === 1 ? 'Stage' : 'Stages'}
            </Badge>
          </CardTitle>
        </CardHeader>
        <CardContent>
          {stages.length === 0 ? (
            <div className="text-center py-8 text-muted-foreground">
              No stages added to this project yet.
            </div>
          ) : viewMode === 'cards' ? (
            <div className="relative">
              {/* Connection lines for card view */}
              <svg className="absolute top-0 left-0 w-full h-full pointer-events-none" style={{ zIndex: 0 }}>
                {connections.map((conn, index) => {
                  const fromElement = document.getElementById(`stage-card-${conn.from_stage._id}`);
                  const toElement = document.getElementById(`stage-card-${conn.to_stage._id}`);
                  
                  if (!fromElement || !toElement) return null;
                  
                  const fromRect = fromElement.getBoundingClientRect();
                  const toRect = toElement.getBoundingClientRect();
                  
                  const containerRect = fromElement.parentElement?.getBoundingClientRect();
                  if (!containerRect) return null;
                  
                  const x1 = fromRect.left + fromRect.width / 2 - containerRect.left;
                  const y1 = fromRect.top + fromRect.height / 2 - containerRect.top;
                  const x2 = toRect.left + toRect.width / 2 - containerRect.left;
                  const y2 = toRect.top + toRect.height / 2 - containerRect.top;
                  
                  return (
                    <line 
                      key={index}
                      x1={x1}
                      y1={y1}
                      x2={x2}
                      y2={y2}
                      stroke="#94a3b8"
                      strokeWidth="2"
                      markerEnd="url(#arrowhead)"
                    />
                  );
                })}
                <defs>
                  <marker 
                    id="arrowhead" 
                    markerWidth="10" 
                    markerHeight="7" 
                    refX="9" 
                    refY="3.5" 
                    orient="auto"
                  >
                    <polygon points="0 0, 10 3.5, 0 7" fill="#94a3b8" />
                  </marker>
                </defs>
              </svg>
              
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 relative" style={{ zIndex: 1 }}>
                {stages.map(stage => (
                  <ProjectStageCard 
                    key={stage._id}
                    stage={stage}
                    onEdit={() => setEditingStage(stage._id)}
                    onDelete={() => deleteProjectStage(stage._id)}
                    onMarkComplete={handleMarkComplete}
                  />
                ))}
              </div>
            </div>
          ) : (
            <ProjectStageTable 
              stages={stages}
              onEdit={(stageId) => setEditingStage(stageId)}
              onDelete={deleteProjectStage}
              onMarkComplete={handleMarkComplete}
            />
          )}
        </CardContent>
      </Card>
      
      {/* Add Stage Form */}
      {showStageForm && (
        <ProjectStageForm
          availableStages={availableStages}
          onSubmit={handleAddStage}
          onCancel={() => {
            setShowStageForm(false);
            setPreSelectedStageId(null);
          }}
          preSelectedStageId={preSelectedStageId || undefined}
        />
      )}
      
      {/* Edit Stage Form */}
      {editingStage && (
        <ProjectStageForm
          stage={stages.find(s => s._id === editingStage)}
          isEditing={true}
          onSubmit={(stageId, status, startDate, completionDate) => 
            handleUpdateStage(editingStage, status, startDate, completionDate)
          }
          onCancel={() => setEditingStage(null)}
        />
      )}
      
      {/* Connection Form */}
      {showConnectionForm && (
        <ConnectionForm
          stages={stages}
          connections={connections}
          onSubmit={handleCreateConnection}
          onCancel={() => setShowConnectionForm(false)}
        />
      )}
    </div>
  );
};








frontend/app/component/projects/ProjectFilterControls.tsx
// frontend/app/component/projects/ProjectFilterControls.tsx
import React from 'react';
import { Button } from '@/components/ui/button';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Input } from '@/components/ui/input';
import { Calendar } from '@/components/ui/calendar';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { CalendarIcon, Search, X } from 'lucide-react';
import { format } from 'date-fns';
import { cn } from '@/lib/utils';
import { SearchBar } from '@/components/ui/search-bar';

interface ProjectFilterControlsProps {
  sortBy: 'newest' | 'oldest';
  statusFilter: string;
  searchTerm: string;
  dateRange: {
    startDate: Date | undefined;
    endDate: Date | undefined;
  };
  onSortChange: (sortBy: 'newest' | 'oldest') => void;
  onStatusFilterChange: (statusFilter: string) => void;
  onSearchChange: (searchTerm: string) => void;
  onDateRangeChange: (dateRange: { startDate: Date | undefined; endDate: Date | undefined }) => void;
}

export const ProjectFilterControls: React.FC<ProjectFilterControlsProps> = ({
  sortBy,
  statusFilter,
  searchTerm,
  dateRange,
  onSortChange,
  onStatusFilterChange,
  onSearchChange,
  onDateRangeChange
}) => {
  const toggleSort = () => {
    onSortChange(sortBy === 'newest' ? 'oldest' : 'newest');
  };
  
  const clearDateRange = () => {
    onDateRangeChange({ startDate: undefined, endDate: undefined });
  };
  
  // Handle start date selection
  const handleStartDateSelect = (date: Date | undefined) => {
    onDateRangeChange({ ...dateRange, startDate: date });
  };
  
  // Handle end date selection
  const handleEndDateSelect = (date: Date | undefined) => {
    onDateRangeChange({ ...dateRange, endDate: date });
  };
  
  // Handle status filter change
  const handleStatusFilterChange = (value: string) => {
    console.log("ProjectFilterControls handleStatusFilterChange:", value); // Debug log
    onStatusFilterChange(value);
  };
  
  return (
    <div className="flex flex-wrap gap-4 mb-6 p-4 bg-gray-50 rounded-lg">
      {/* Search Input using the reusable SearchBar component */}
      <div className="flex-1 min-w-[250px]">
        <SearchBar 
          placeholder="Search projects..." 
          value={searchTerm} 
          onChange={onSearchChange} 
        />
      </div>
      
      {/* Sort Button */}
      <div className="flex items-center gap-2">
        <span className="text-sm font-medium text-gray-700">Sort:</span>
        <Button variant="outline" size="sm" onClick={toggleSort} className="flex items-center gap-1">
          {sortBy === 'newest' ? 'Newest' : 'Oldest'}
          <CalendarIcon className="h-3 w-3" />
        </Button>
      </div>
      
      {/* Status Filter */}
      <div className="flex items-center gap-2">
        <span className="text-sm font-medium text-gray-700">Status:</span>
        <Select value={statusFilter} onValueChange={handleStatusFilterChange}>
          <SelectTrigger className="w-40">
            <SelectValue placeholder="All statuses" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">All Statuses</SelectItem>
            <SelectItem value="Pending">Pending</SelectItem>
            <SelectItem value="Ongoing">Ongoing</SelectItem>
            <SelectItem value="Completed">Completed</SelectItem>
            <SelectItem value="Archived">Archived</SelectItem>
          </SelectContent>
        </Select>
      </div>
      
      {/* Date Range Filter */}
      <div className="flex items-center gap-2">
        <span className="text-sm font-medium text-gray-700">Date Range:</span>
        <div className="flex gap-2">
          <Popover>
            <PopoverTrigger asChild>
              <Button variant="outline" className={cn(
                "w-[140px] justify-start text-left font-normal",
                !dateRange.startDate && "text-muted-foreground"
              )}>
                {dateRange.startDate ? (
                  format(dateRange.startDate, "MMM dd, yyyy")
                ) : (
                  <span>Start date</span>
                )}
              </Button>
            </PopoverTrigger>
            <PopoverContent className="w-auto p-0">
              <Calendar
                mode="single"
                selected={dateRange.startDate}
                onSelect={handleStartDateSelect}
                initialFocus
              />
            </PopoverContent>
          </Popover>
          
          <Popover>
            <PopoverTrigger asChild>
              <Button variant="outline" className={cn(
                "w-[140px] justify-start text-left font-normal",
                !dateRange.endDate && "text-muted-foreground"
              )}>
                {dateRange.endDate ? (
                  format(dateRange.endDate, "MMM dd, yyyy")
                ) : (
                  <span>End date</span>
                )}
              </Button>
            </PopoverTrigger>
            <PopoverContent className="w-auto p-0">
              <Calendar
                mode="single"
                selected={dateRange.endDate}
                onSelect={handleEndDateSelect}
                initialFocus
              />
            </PopoverContent>
          </Popover>
          
          {(dateRange.startDate || dateRange.endDate) && (
            <Button variant="ghost" size="sm" onClick={clearDateRange} className="text-gray-500">
              <X className="h-4 w-4" />
            </Button>
          )}
        </div>
      </div>
    </div>
  );
};







frontend/app/component/projects/ProjectForm.tsx
// frontend/app/components/projects/projectForm.tsx
import React, { useEffect, useState } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter, DialogDescription } from "@/components/ui/dialog";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Calendar } from "@/components/ui/calendar";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { CalendarIcon } from "lucide-react";
import { format } from "date-fns";
import { cn } from "@/lib/utils";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Button } from "@/components/ui/button";
import { projectSchema, type ProjectEntry } from "@/lib/schema";
import { z } from "zod";

interface ProjectFormProps {
  isOpen: boolean;
  onClose: () => void;
  project?: ProjectEntry | null;
  onSubmit: (values: z.infer<typeof projectSchema>) => void;
}

// Helper function to format date as YYYY-MM-DD without timezone conversion
const formatDateForSubmission = (date: Date): string => {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
};

export const ProjectForm: React.FC<ProjectFormProps> = ({
  isOpen,
  onClose,
  project,
  onSubmit
}) => {
  const [date, setDate] = useState<Date | undefined>(undefined);
  const form = useForm<z.infer<typeof projectSchema>>({
    resolver: zodResolver(projectSchema),
    defaultValues: {
      project_name: "",
      description: "",
      status: "Pending",
      created_at: new Date().toISOString().split('T')[0],
    },
  });

  // Reset form when project changes or dialog opens/closes
  useEffect(() => {
    if (isOpen && project) {
      // Editing existing project
      const projectDate = new Date(project.created_at);
      setDate(projectDate);
      form.reset({
        project_name: project.project_name || "",
        description: project.description || "",
        status: project.status || "Pending",
        created_at: project.created_at,
      });
    } else if (isOpen) {
      // Creating new project
      const today = new Date();
      setDate(today);
      form.reset({
        project_name: "",
        description: "",
        status: "Pending",
        created_at: formatDateForSubmission(today),
      });
    } else {
      // Dialog closed
      form.reset();
      setDate(undefined);
    }
  }, [isOpen, project, form]);

  // Handle date selection from calendar
  const handleDateSelect = (selectedDate: Date | undefined) => {
    setDate(selectedDate);
    if (selectedDate) {
      // Format date as YYYY-MM-DD for form submission without timezone conversion
      const formattedDate = formatDateForSubmission(selectedDate);
      form.setValue("created_at", formattedDate);
    }
  };

  const handleSubmit = (values: z.infer<typeof projectSchema>) => {
    onSubmit(values);
    form.reset();
    setDate(undefined);
  };

  const handleCancel = () => {
    form.reset();
    setDate(undefined);
    onClose();
  };

  return (
    <Dialog open={isOpen} onOpenChange={handleCancel}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>
            {project ? "Edit Project" : "Create Project"}
          </DialogTitle>
          <DialogDescription>
            {project ? "Update the project details below." : "Fill in the details to create a new project."}
          </DialogDescription>
        </DialogHeader>
        <Form {...form}>
          <form onSubmit={form.handleSubmit(handleSubmit)}>
            <FormField
              control={form.control}
              name="project_name"
              render={({ field }) => (
                <FormItem className="mb-4">
                  <FormLabel>Project Name</FormLabel>
                  <FormControl>
                    <Input placeholder="Enter Project Name" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem className="mb-4">
                  <FormLabel>Description</FormLabel>
                  <FormControl>
                    <Textarea placeholder="Enter Project Description" className="min-h-[100px]" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            <FormField
              control={form.control}
              name="status"
              render={({ field }) => (
                <FormItem className="mb-4">
                  <FormLabel>Status</FormLabel>
                  <Select onValueChange={field.onChange} value={field.value}>
                    <FormControl>
                      <SelectTrigger>
                        <SelectValue placeholder="Select a status" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      <SelectItem value="Pending">Pending</SelectItem>
                      <SelectItem value="Ongoing">Ongoing</SelectItem>
                      <SelectItem value="Completed">Completed</SelectItem>
                      <SelectItem value="Archived">Archived</SelectItem>
                    </SelectContent>
                  </Select>
                  <FormMessage />
                </FormItem>
              )}
            />
            <FormField
              control={form.control}
              name="created_at"
              render={({ field }) => (
                <FormItem className="mb-4">
                  <FormLabel>Created At</FormLabel>
                  <Popover>
                    <PopoverTrigger asChild>
                      <FormControl>
                        <Button
                          variant={"outline"}
                          className={cn(
                            "w-full pl-3 text-left font-normal",
                            !date && "text-muted-foreground"
                          )}
                        >
                          {date ? (
                            format(date, "PPP")
                          ) : (
                            <span>Pick a date</span>
                          )}
                          <CalendarIcon className="ml-auto h-4 w-4 opacity-50" />
                        </Button>
                      </FormControl>
                    </PopoverTrigger>
                    <PopoverContent className="w-auto p-0" align="start">
                      <Calendar
                        mode="single"
                        selected={date}
                        onSelect={handleDateSelect}
                        disabled={(date) => date < new Date("1900-01-01")}
                        initialFocus
                      />
                    </PopoverContent>
                  </Popover>
                  <FormMessage />
                </FormItem>
              )}
            />
            <DialogFooter className="mt-4">
              <Button type="submit">
                {project ? "Update Project" : "Create Project"}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
};









frontend/app/component/projects/project-card.tsx
// frontend/app/components/projects/project-card.tsx
import React from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Pencil, Trash2, Calendar } from "lucide-react";
import { format } from "date-fns";
import { type ProjectEntry } from "@/lib/schema";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";

interface ProjectCardProps {
  project: ProjectEntry;
  onEdit: (project: ProjectEntry) => void;
  onDelete: (id: string) => void;
  onProjectClick: (id: string) => void;
}

export const ProjectCard: React.FC<ProjectCardProps> = ({ 
  project, 
  onEdit, 
  onDelete,
  onProjectClick
}) => {
  // Get status badge color based on status value
  const getStatusBadgeClass = (status?: string) => {
    switch (status) {
      case 'Pending': return 'bg-yellow-100 text-yellow-800';
      case 'Ongoing': return 'bg-blue-100 text-blue-800';
      case 'Completed': return 'bg-green-100 text-green-800';
      case 'Archived': return 'bg-gray-100 text-gray-800';
      default: return 'bg-gray-100 text-gray-800';
    }
  };

  // Format date for display
  const formatDisplayDate = (dateString: string) => {
    try {
      return format(new Date(dateString), "MMM dd, yyyy");
    } catch (error) {
      return dateString;
    }
  };

  return (
    <Card 
      className="h-full flex flex-col cursor-pointer hover:shadow-md transition-shadow"
      onClick={() => onProjectClick(project._id)}
    >
      <CardHeader className="pb-3">
        <div className="flex justify-between items-start">
          <Tooltip>
            <TooltipTrigger asChild>
              <CardTitle className="text-lg font-semibold line-clamp-2">
                {project.project_name}
              </CardTitle>
            </TooltipTrigger>
            <TooltipContent>
              <p>{project.project_name}</p>
            </TooltipContent>
          </Tooltip>
          <div className="flex gap-1">
            <Button 
              variant="ghost" 
              size="sm" 
              className="text-yellow-500 hover:text-yellow-700 h-8 w-8 p-0"
              onClick={(e) => {
                e.stopPropagation();
                onEdit(project);
              }}
            >
              <Pencil className="h-4 w-4" />
            </Button>
            <Button 
              variant="ghost" 
              size="sm" 
              className="text-red-500 hover:text-red-700 h-8 w-8 p-0"
              onClick={(e) => {
                e.stopPropagation();
                onDelete(project._id);
              }}
            >
              <Trash2 className="h-4 w-4" />
            </Button>
          </div>
        </div>
        <div className="flex items-center gap-2 mt-2">
          <Badge variant="secondary" className={getStatusBadgeClass(project.status)}>
            {project.status || 'Unknown'}
          </Badge>
          <div className="flex items-center text-sm text-muted-foreground">
            <Calendar className="mr-1 h-3 w-3" />
            {formatDisplayDate(project.created_at)}
          </div>
        </div>
      </CardHeader>
      <CardContent className="flex-grow">
        <CardDescription className="line-clamp-3 text-sm">
          {project.description || "No description provided."}
        </CardDescription>
      </CardContent>
    </Card>
  );
};







frontend/app/component/projects/ProjectStageForm.tsx
// frontend/app/components/projects/ProjectStageForm.tsx
import React, { useState, useEffect } from "react";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter, DialogDescription } from "@/components/ui/dialog";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Calendar } from "@/components/ui/calendar";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { Button } from "@/components/ui/button";
import { CalendarIcon } from "lucide-react";
import { format } from "date-fns";
import { cn } from "@/lib/utils";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { type StageEntry, type ProjectStageEntry } from "@/lib/schema";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { AlertCircle } from "lucide-react";

const stageFormSchema = z.object({
  stageId: z.string().min(1, { message: "Stage is required" }),
  status: z.enum(['Ongoing', 'Completed']),
  startDate: z.string().optional(),
  completionDate: z.string().optional(),
});

type StageFormValues = z.infer<typeof stageFormSchema>;

interface ProjectStageFormProps {
  availableStages?: StageEntry[];
  stage?: ProjectStageEntry;
  isEditing?: boolean;
  onSubmit: (stageId: string, status: 'Ongoing' | 'Completed', startDate?: string, completionDate?: string) => void;
  onCancel: () => void;
  preSelectedStageId?: string;
}

export const ProjectStageForm: React.FC<ProjectStageFormProps> = ({
  availableStages = [],
  stage,
  isEditing = false,
  onSubmit,
  onCancel,
  preSelectedStageId
}) => {
  const [status, setStatus] = useState<'Ongoing' | 'Completed'>(stage?.status || 'Ongoing');
  const [showAlert, setShowAlert] = useState(false);
  const [alertMessage, setAlertMessage] = useState("");

  const form = useForm<StageFormValues>({
    resolver: zodResolver(stageFormSchema),
    defaultValues: {
      stageId: preSelectedStageId || stage?.stage._id || '',
      status: stage?.status || 'Ongoing',
      startDate: stage?.start_date ? format(new Date(stage.start_date), 'yyyy-MM-dd') : '',
      completionDate: stage?.completion_date ? format(new Date(stage.completion_date), 'yyyy-MM-dd') : '',
    },
  });

  const watchedStatus = form.watch('status');
  const watchedStartDate = form.watch('startDate');
  const watchedCompletionDate = form.watch('completionDate');

  useEffect(() => {
    if (watchedStatus) {
      setStatus(watchedStatus as 'Ongoing' | 'Completed');
    }
  }, [watchedStatus]);

  const validateForm = () => {
    if (status === 'Ongoing' && !watchedStartDate) {
      setAlertMessage("Start date is required for Ongoing status");
      setShowAlert(true);
      return false;
    }
    
    if (status === 'Completed' && (!watchedStartDate || !watchedCompletionDate)) {
      setAlertMessage("Both start date and completion date are required for Completed status");
      setShowAlert(true);
      return false;
    }
    
    setShowAlert(false);
    return true;
  };

  const handleSubmit = (values: StageFormValues) => {
    if (!validateForm()) {
      return;
    }
    
    onSubmit(
      values.stageId,
      values.status,
      values.startDate,
      values.completionDate
    );
  };

  return (
    <Dialog open={true} onOpenChange={onCancel}>
      <DialogContent className="sm:max-w-[500px] max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>
            {isEditing ? 'Edit Project Stage' : 'Add Stage to Project'}
          </DialogTitle>
          <DialogDescription>
            {isEditing
              ? "Update the stage details below."
              : "Fill in the details to create a new stage."
            }
          </DialogDescription>
        </DialogHeader>
        
        {showAlert && (
          <Alert variant="destructive">
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>{alertMessage}</AlertDescription>
          </Alert>
        )}
        
        <Form {...form}>
          <form onSubmit={form.handleSubmit(handleSubmit)} className="space-y-4">
            {!isEditing && (
              <FormField
                control={form.control}
                name="stageId"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Stage</FormLabel>
                    <Select onValueChange={field.onChange} defaultValue={field.value}>
                      <FormControl>
                        <SelectTrigger className="h-auto py-2">
                          <SelectValue placeholder="Select a stage" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        {availableStages.map(stage => (
                          <SelectItem key={stage._id} value={stage._id} className="whitespace-normal">
                            <div className="max-w-xs">
                              <div className="whitespace-normal break-words">
                                {stage.stage_name}
                              </div>
                            </div>
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />
            )}
            
            <FormField
              control={form.control}
              name="status"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Status</FormLabel>
                  <Select onValueChange={(value) => {
                    field.onChange(value);
                    setStatus(value as 'Ongoing' | 'Completed');
                  }} defaultValue={field.value}>
                    <FormControl>
                      <SelectTrigger>
                        <SelectValue placeholder="Select status" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      <SelectItem value="Ongoing">Ongoing</SelectItem>
                      <SelectItem value="Completed">Completed</SelectItem>
                    </SelectContent>
                  </Select>
                  <FormMessage />
                </FormItem>
              )}
            />
            
            <FormField
              control={form.control}
              name="startDate"
              render={({ field }) => (
                <FormItem className="flex flex-col">
                  <FormLabel>Start Date {status === 'Ongoing' && <span className="text-red-500">*</span>}</FormLabel>
                  <Popover>
                    <PopoverTrigger asChild>
                      <FormControl>
                        <Button
                          variant={"outline"}
                          className={cn(
                            "w-full pl-3 text-left font-normal",
                            !field.value && "text-muted-foreground"
                          )}
                        >
                          {field.value ? (
                            format(new Date(field.value), "PPP")
                          ) : (
                            <span>Pick a date</span>
                          )}
                          <CalendarIcon className="ml-auto h-4 w-4 opacity-50" />
                        </Button>
                      </FormControl>
                    </PopoverTrigger>
                    <PopoverContent className="w-auto p-0" align="start">
                      <Calendar
                        mode="single"
                        selected={field.value ? new Date(field.value) : undefined}
                        onSelect={(date) => {
                          if (date) {
                            field.onChange(format(date, 'yyyy-MM-dd'));
                          }
                        }}
                        // Remove the date restriction to allow future dates
                        initialFocus
                      />
                    </PopoverContent>
                  </Popover>
                  <FormMessage />
                </FormItem>
              )}
            />
            
            {status === 'Completed' && (
              <FormField
                control={form.control}
                name="completionDate"
                render={({ field }) => (
                  <FormItem className="flex flex-col">
                    <FormLabel>Completion Date <span className="text-red-500">*</span></FormLabel>
                    <Popover>
                      <PopoverTrigger asChild>
                        <FormControl>
                          <Button
                            variant={"outline"}
                            className={cn(
                              "w-full pl-3 text-left font-normal",
                              !field.value && "text-muted-foreground"
                            )}
                          >
                            {field.value ? (
                              format(new Date(field.value), "PPP")
                            ) : (
                              <span>Pick a date</span>
                            )}
                            <CalendarIcon className="ml-auto h-4 w-4 opacity-50" />
                          </Button>
                        </FormControl>
                      </PopoverTrigger>
                      <PopoverContent className="w-auto p-0" align="start">
                        <Calendar
                          mode="single"
                          selected={field.value ? new Date(field.value) : undefined}
                          onSelect={(date) => {
                            if (date) {
                              field.onChange(format(date, 'yyyy-MM-dd'));
                            }
                          }}
                          // Remove the date restriction to allow future dates
                          initialFocus
                        />
                      </PopoverContent>
                    </Popover>
                    <FormMessage />
                  </FormItem>
                )}
              />
            )}
            
            <DialogFooter className="mt-4">
              <Button type="button" variant="outline" onClick={onCancel}>
                Cancel
              </Button>
              <Button type="submit">
                {isEditing ? 'Update Stage' : 'Add Stage'}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
};







frontend/app/component/ProjectStageTable.tsx
// frontend/app/components/projects/ProjectStageTable.tsx
import React from "react";
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Trash2, Edit, CheckCircle, MoreHorizontal } from "lucide-react";
import { format } from "date-fns";
import { type ProjectStageEntry } from "@/lib/schema";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";

interface ProjectStageTableProps {
  stages: ProjectStageEntry[];
  onEdit: (stageId: string) => void;
  onDelete: (stageId: string) => void;
  onMarkComplete: (stageId: string) => void;
}

export const ProjectStageTable: React.FC<ProjectStageTableProps> = ({
  stages,
  onEdit,
  onDelete,
  onMarkComplete
}) => {
  const formatDisplayDate = (dateString?: string) => {
    if (!dateString) return "Not set";
    try {
      return format(new Date(dateString), "MMM dd, yyyy");
    } catch (error) {
      return dateString;
    }
  };
  
  const getStatusColor = (status: string) => {
    switch (status) {
      case 'Ongoing': return 'bg-blue-100 text-blue-800';
      case 'Completed': return 'bg-green-100 text-green-800';
      default: return 'bg-gray-100 text-gray-800';
    }
  };
  
  // Sort stages by date (oldest first)
const sortedStages = [...stages].sort((a, b) => {
  const dateA = a.start_date ? new Date(a.start_date).getTime() : Infinity;
  const dateB = b.start_date ? new Date(b.start_date).getTime() : Infinity;
  return dateA - dateB;
});

  
  return (
    <div className="rounded-md border">
      <Table>
        <TableHeader>
          <TableRow>
            <TableHead className="w-[40px]">#</TableHead>
            <TableHead className="w-[200px]">Stage Name</TableHead>
            <TableHead className="w-[250px]">Description</TableHead>
            <TableHead>Status</TableHead>
            <TableHead>Start Date</TableHead>
            <TableHead>Completion Date</TableHead>
            <TableHead className="text-right">Actions</TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {sortedStages.map((stage, index) => (
            <TableRow key={stage._id}>
              <TableCell>{index + 1}</TableCell>
              <TableCell className="whitespace-normal break-words">
                {stage.stage.stage_name}
              </TableCell>
              <TableCell className="whitespace-normal break-words">
                {stage.stage.description || "No description"}
              </TableCell>
              <TableCell>
                <Badge className={getStatusColor(stage.status)}>
                  {stage.status}
                </Badge>
              </TableCell>
              <TableCell>{formatDisplayDate(stage.start_date)}</TableCell>
              <TableCell>{formatDisplayDate(stage.completion_date)}</TableCell>
              <TableCell className="text-right">
                <DropdownMenu>
                  <DropdownMenuTrigger asChild>
                    <Button variant="ghost" size="sm">
                      <MoreHorizontal className="h-4 w-4" />
                    </Button>
                  </DropdownMenuTrigger>
                  <DropdownMenuContent align="end">
                    <DropdownMenuItem onClick={() => onEdit(stage._id)}>
                      <Edit className="mr-2 h-4 w-4" />
                      Edit
                    </DropdownMenuItem>
                    <DropdownMenuItem onClick={() => onDelete(stage._id)} className="text-red-500">
                      <Trash2 className="mr-2 h-4 w-4" />
                      Delete
                    </DropdownMenuItem>
                    {stage.status === 'Ongoing' && (
                      <DropdownMenuItem onClick={() => onMarkComplete(stage._id)}>
                        <CheckCircle className="mr-2 h-4 w-4" />
                        Mark Complete
                      </DropdownMenuItem>
                    )}
                  </DropdownMenuContent>
                </DropdownMenu>
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </div>
  );
};





frontend/app/component/ProjectTable.tsx
// frontend/app/components/projects/ProjectTable.tsx
import React from 'react';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import { ArrowUpDown, Pencil, Trash2 } from "lucide-react";
import { format } from "date-fns";
import { type ProjectEntry } from "@/lib/schema";

interface ProjectTableProps {
  projects: ProjectEntry[];
  onEdit: (project: ProjectEntry) => void;
  onDelete: (id: string) => void;
  onProjectClick: (id: string) => void;
  onSortToggle: () => void;
  sortBy: 'newest' | 'oldest';
  isLoading: boolean;
  hasProjects: boolean;
  hasFilteredProjects: boolean;
}

export const ProjectTable: React.FC<ProjectTableProps> = ({ 
  projects, 
  onEdit, 
  onDelete,
  onProjectClick,
  onSortToggle, 
  sortBy, 
  isLoading, 
  hasProjects, 
  hasFilteredProjects 
}) => {
  // Format date for display in the table
  const formatDisplayDate = (dateString: string) => {
    try {
      return format(new Date(dateString), "MMM dd, yyyy");
    } catch (error) {
      return dateString;
    }
  };

  // Get status badge color based on status value
  const getStatusBadgeClass = (status?: string) => {
    switch (status) {
      case 'Pending': return 'bg-yellow-100 text-yellow-800';
      case 'Ongoing': return 'bg-blue-100 text-blue-800';
      case 'Completed': return 'bg-green-100 text-green-800';
      case 'Archived': return 'bg-gray-100 text-gray-800';
      default: return 'bg-gray-100 text-gray-800'; // Default for undefined or other values
    }
  };

  if (isLoading) {
    return <div>Loading projects...</div>;
  }

  return (
    <div className="rounded-md border">
      <Table>
        <TableHeader>
          <TableRow>
            <TableHead className="w-[50px]">#</TableHead>
            <TableHead className="w-[200px]">Project Name</TableHead>
            <TableHead className="w-[300px]">Description</TableHead>
            <TableHead className="w-[120px]">Status</TableHead>
            <TableHead className="w-[120px]">
              <Button variant="ghost" className="h-auto p-0 font-semibold flex items-center gap-1" onClick={onSortToggle}>
                Created At <ArrowUpDown className="h-3 w-3" />
              </Button>
            </TableHead>
            <TableHead className="w-[100px] text-right">Actions</TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {projects.length === 0 ? (
            <TableRow>
              <TableCell colSpan={6} className="text-center h-32">
                {hasProjects ? "No projects match the selected filters." : "No projects found."}
              </TableCell>
            </TableRow>
          ) : (
            projects.map((project, index) => (
              <TableRow 
                key={project._id} 
                className="cursor-pointer hover:bg-muted/50"
                onClick={() => onProjectClick(project._id)}
              >
                <TableCell>{index + 1}</TableCell>
                <TableCell className="whitespace-normal break-words" title={project.project_name}>
                  {project.project_name}
                </TableCell>
                <TableCell className="whitespace-normal break-words" title={project.description}>
                  {project.description}
                </TableCell>
                <TableCell>
                  <div className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${getStatusBadgeClass(project.status)}`}>
                    {project.status || 'Unknown'}
                  </div>
                </TableCell>
                <TableCell>
                  {formatDisplayDate(project.created_at)}
                </TableCell>
                <TableCell className="text-right">
                  <Button 
                    variant="ghost" 
                    size="sm" 
                    className="text-yellow-500 hover:text-yellow-700"
                    onClick={(e) => {
                      e.stopPropagation();
                      onEdit(project);
                    }}
                  >
                    <Pencil className="h-4 w-4" />
                  </Button>
                  <Button 
                    variant="ghost" 
                    size="sm" 
                    className="text-red-500 hover:text-red-700 ml-2"
                    onClick={(e) => {
                      e.stopPropagation();
                      onDelete(project._id);
                    }}
                  >
                    <Trash2 className="h-4 w-4" />
                  </Button>
                </TableCell>
              </TableRow>
            ))
          )}
        </TableBody>
      </Table>
    </div>
  );
};




frontend/app/component/stages/stage-management.tsx
"use client";
import React, { useState, useMemo } from "react";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
  DialogDescription,
} from "@/components/ui/dialog";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Loader } from "@/components/loader";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { TriangleAlert, Trash2, Pencil, Plus } from "lucide-react";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { useStages } from "@/hooks/use-stages";
import { stageSchema, type StageEntry } from "@/lib/schema";
import { z } from "zod";
import { SearchBar } from "@/components/ui/search-bar";

const StageManagement = () => {
  const { stages, isLoading, error, addStage, updateStage, deleteStage } = useStages();
  const [showModal, setShowModal] = useState(false);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [stageToDelete, setStageToDelete] = useState<string | null>(null);
  const [currentStage, setCurrentStage] = useState<StageEntry | null>(null);
  const [searchTerm, setSearchTerm] = useState<string>('');

  const form = useForm<z.infer<typeof stageSchema>>({
    resolver: zodResolver(stageSchema),
    defaultValues: {
      stage_name: "",
      description: "",
    },
  });

  // Filter stages based on search term
  const filteredStages = useMemo(() => {
    if (!searchTerm) return stages;
    
    const term = searchTerm.toLowerCase();
    return stages.filter(stage => 
      stage.stage_name.toLowerCase().includes(term) ||
      (stage.description && stage.description.toLowerCase().includes(term))
    );
  }, [stages, searchTerm]);

  const handleAddClick = () => {
    setCurrentStage(null);
    form.reset({ stage_name: "", description: "" });
    setShowModal(true);
  };

  const handleEditClick = (stage: StageEntry) => {
    setCurrentStage(stage);
    form.reset({ 
      stage_name: stage.stage_name, 
      description: stage.description || ""
    });
    setShowModal(true);
  };

  const handleDeleteClick = (_id: string) => {
    setStageToDelete(_id);
    setShowDeleteDialog(true);
  };

  const handleConfirmDelete = async () => {
    if (stageToDelete) {
      await deleteStage(stageToDelete);
    }
    setShowDeleteDialog(false);
    setStageToDelete(null);
  };

  const handleSubmit = async (values: z.infer<typeof stageSchema>) => {
    if (currentStage) {
      // Editing an existing stage
      await updateStage(currentStage._id, values);
    } else {
      // Adding a new stage
      await addStage(values);
    }
    setShowModal(false);
  };

  return (
    <div className="container mx-auto p-4 pt-0">
      {/* Header with no bottom margin */}
      <div className="flex items-center justify-between mb-0">
        <h3 className="text-xl font-bold">Stage Management</h3>
        <Button onClick={handleAddClick} className="flex items-center gap-1 text-sm py-1 h-8">
          <Plus className="h-3 w-3" /> Add Stage
        </Button>
      </div>
      
      {/* Search Input using the reusable SearchBar component */}
      <div className="mb-4 p-3 bg-gray-50 rounded-lg">
        <SearchBar
          placeholder="Search stages by name or description..."
          value={searchTerm}
          onChange={setSearchTerm}
        />
      </div>
      
      {error && (
        <Alert variant="destructive" className="mb-2">
          <TriangleAlert className="h-4 w-4" />
          <AlertTitle>Error</AlertTitle>
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}
      
      {/* Scrollable table container */}
      <div className="overflow-y-auto max-h-[calc(100vh-200px)]">
        {isLoading ? (
          <Loader />
        ) : (
          <div className="rounded-md border">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead className="w-[50px]">#</TableHead>
                  <TableHead className="w-[200px]">Stage Name</TableHead>
                  <TableHead className="w-[300px]">Description</TableHead>
                  <TableHead className="w-[100px] text-right">Actions</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {filteredStages.length === 0 ? (
                  <TableRow>
                    <TableCell colSpan={4} className="text-center h-32">
                      {stages.length === 0 ? "No stages found." : "No stages match your search."}
                    </TableCell>
                  </TableRow>
                ) : (
                  filteredStages.map((stage, index) => (
                    <TableRow key={stage._id}>
                      <TableCell>{index + 1}</TableCell>
                      <TableCell className="whitespace-normal break-words" title={stage.stage_name}>
                        {stage.stage_name}
                      </TableCell>
                      <TableCell className="whitespace-normal break-words" title={stage.description}>
                        {stage.description}
                      </TableCell>
                      <TableCell className="text-right">
                        <Button
                          variant="ghost"
                          size="sm"
                          className="text-yellow-500 hover:text-yellow-700"
                          onClick={() => handleEditClick(stage)}
                        >
                          <Pencil className="h-4 w-4" />
                        </Button>
                        <Button
                          variant="ghost"
                          size="sm"
                          className="text-red-500 hover:text-red-700 ml-2"
                          onClick={() => handleDeleteClick(stage._id)}
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </TableCell>
                    </TableRow>
                  ))
                )}
              </TableBody>
            </Table>
          </div>
        )}
      </div>
      
      {/* Modal for Adding & Editing Stages */}
      <Dialog open={showModal} onOpenChange={setShowModal}>
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle>
              {currentStage ? "Edit Stage" : "Add Stage"}
            </DialogTitle>
            <DialogDescription>
              {currentStage 
                ? "Update the stage details below." 
                : "Fill in the details to create a new stage."
              }
            </DialogDescription>
          </DialogHeader>
          <Form {...form}>
            <form onSubmit={form.handleSubmit(handleSubmit)}>
              <FormField
                control={form.control}
                name="stage_name"
                render={({ field }) => (
                  <FormItem className="mb-4">
                    <FormLabel>Stage Name</FormLabel>
                    <FormControl>
                      <Input placeholder="Enter Stage Name" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="description"
                render={({ field }) => (
                  <FormItem className="mb-4">
                    <FormLabel>Description</FormLabel>
                    <FormControl>
                      <Textarea 
                        placeholder="Enter Stage Description" 
                        className="min-h-[100px]"
                        {...field} 
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <DialogFooter className="mt-4">
                <Button type="submit">
                  {currentStage ? "Update Stage" : "Add Stage"}
                </Button>
              </DialogFooter>
            </form>
          </Form>
        </DialogContent>
      </Dialog>
      
      {/* Custom Confirmation Dialog for Deleting */}
      <AlertDialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete the stage.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={handleConfirmDelete}>Continue</AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
};

export default StageManagement;









frontend/app/hoooks/use-email.ts

import { useState, useEffect } from "react";
import { type EmailEntry, emailSchema } from "@/lib/schema"; // Import schema and type
import { z } from "zod";

const API_BASE_URL = "http://localhost:5000/api-v1/emails";

// A custom hook to manage all email-related data and logic
export const useEmails = () => {
  const [emails, setEmails] = useState<EmailEntry[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Function to fetch all emails from the backend
  const fetchEmails = async () => {
    setIsLoading(true);
    setError(null);
    try {
      const res = await fetch(`${API_BASE_URL}/all-emails`);
      if (!res.ok) {
        throw new Error("Failed to fetch emails.");
      }
      const data = await res.json();
      setEmails(data);
    } catch (err) {
      console.error("Error fetching emails:", err);
      setError("Failed to load emails. Please try again later.");
    } finally {
      setIsLoading(false);
    }
  };

  // Function to add a new email
  const addEmail = async (newEmail: z.infer<typeof emailSchema>) => {
    try {
      const res = await fetch(`${API_BASE_URL}/add-email`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(newEmail),
      });
      if (!res.ok) {
        throw new Error("Failed to add email.");
      }
      // Re-fetch the email list to update the UI
      fetchEmails();
    } catch (err) {
      console.error("Error adding email:", err);
      setError("Failed to add email. Please try again.");
    }
  };

  // Function to update an existing email
  const updateEmail = async (id: string, updatedEmail: z.infer<typeof emailSchema>) => {
    try {
      const res = await fetch(`${API_BASE_URL}/update-email/${id}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(updatedEmail),
      });
      if (!res.ok) {
        throw new Error("Failed to update email.");
      }
      fetchEmails();
    } catch (err) {
      console.error("Error updating email:", err);
      setError("Failed to update email. Please try again.");
    }
  };

  // Function to delete an email
  const deleteEmail = async (id: string) => {
    try {
      const res = await fetch(`${API_BASE_URL}/delete-email/${id}`, {
        method: "DELETE",
      });
      if (!res.ok) {
        throw new Error("Failed to delete email.");
      }
      fetchEmails();
    } catch (err) {
      console.error("Error deleting email:", err);
      setError("Failed to delete email. Please try again.");
    }
  };

  // Fetch emails on initial render
  useEffect(() => {
    fetchEmails();
  }, []);

  return {
    emails,
    isLoading,
    error,
    fetchEmails,
    addEmail,
    updateEmail,
    deleteEmail,
  };
};













frontend/app/hoooks/use-project.ts
// frontend/app/hooks/use-projects.ts
import { useState, useEffect, useCallback } from "react";
import { type ProjectEntry, projectSchema } from "@/lib/schema";
import { z } from "zod";

const API_BASE_URL = "http://localhost:5000/api-v1";

export const useProjects = () => {
  const [projects, setProjects] = useState<ProjectEntry[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // Memoize fetchProjects to prevent unnecessary re-renders
  const fetchProjects = useCallback(async (filters?: { year?: string; month?: string }) => {
    setIsLoading(true);
    setError(null);
    try {
      // Build query string from filters
      const queryParams = new URLSearchParams();
      
      // Only add year filter if it's not "all" and not empty
      if (filters?.year && filters.year !== 'all') {
        queryParams.append('year', filters.year);
      }
      
      if (filters?.month) {
        queryParams.append('month', filters.month);
      }
      
      const queryString = queryParams.toString();
      const url = `${API_BASE_URL}/projects/all-projects${queryString ? `?${queryString}` : ''}`;
      
      console.log("Fetching projects from:", url); // Debug log
      
      const res = await fetch(url);
      if (!res.ok) {
        const errorData = await res.json();
        throw new Error(errorData.message || "Failed to fetch projects.");
      }
      const data = await res.json();
      console.log("Projects data received:", data); // Debug log
      setProjects(data);
    } catch (err) {
      console.error("Error fetching projects:", err);
      setError(err instanceof Error ? err.message : "Failed to load projects. Please try again later.");
    } finally {
      setIsLoading(false);
    }
  }, []);
  
  // New function to fetch available years
  const fetchProjectYears = useCallback(async () => {
    try {
      const res = await fetch(`${API_BASE_URL}/projects/project-years`);
      if (!res.ok) {
        throw new Error("Failed to fetch project years.");
      }
      const data = await res.json();
      return data;
    } catch (err) {
      console.error("Error fetching project years:", err);
      setError(err instanceof Error ? err.message : "Failed to fetch project years.");
      return [];
    }
  }, []);
  
  const createProject = useCallback(async (newProject: z.infer<typeof projectSchema>) => {
    try {
      const res = await fetch(`${API_BASE_URL}/projects/project`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(newProject),
      });
      if (!res.ok) {
        throw new Error("Failed to create project.");
      }
      await fetchProjects();
    } catch (err) {
      console.error("Error creating project:", err);
      setError("Failed to create project. Please try again.");
    }
  }, [fetchProjects]);
  
  // Update to handle partial updates
  const updateProject = useCallback(async (id: string, updatedProject: Partial<z.infer<typeof projectSchema>>) => {
    try {
      const res = await fetch(`${API_BASE_URL}/projects/${id}`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(updatedProject),
      });
      if (!res.ok) {
        throw new Error("Failed to update project.");
      }
      await fetchProjects();
    } catch (err) {
      console.error("Error updating project:", err);
      setError("Failed to update project. Please try again.");
    }
  }, [fetchProjects]);
  
  const deleteProject = useCallback(async (id: string) => {
    try {
      const res = await fetch(`${API_BASE_URL}/projects/delete-project/${id}`, {
        method: "DELETE",
      });
      if (!res.ok) {
        throw new Error("Failed to delete project.");
      }
      await fetchProjects();
    } catch (err) {
      console.error("Error deleting project:", err);
      setError("Failed to delete project. Please try again.");
    }
  }, [fetchProjects]);
  
  // Initial fetch on mount
  useEffect(() => {
    fetchProjects();
  }, [fetchProjects]);
  
  return {
    projects,
    isLoading,
    error,
    createProject,
    updateProject,
    deleteProject,
    fetchProjects,
    fetchProjectYears,
    refetch: fetchProjects
  };
};










frontend/app/hoooks/use-stage.ts
// frontend/app/hooks/useStages.ts
import { useState, useEffect } from "react";
import { type StageEntry, stageSchema } from "@/lib/schema";
import { z } from "zod";

const API_BASE_URL = "http://localhost:5000/api-v1";

export const useStages = () => {
  const [stages, setStages] = useState<StageEntry[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchStages = async () => {
    setIsLoading(true);
    setError(null);
    try {
      const res = await fetch(`${API_BASE_URL}/stages/all-stages`);
      if (!res.ok) {
        throw new Error("Failed to fetch stages.");
      }
      const data = await res.json();
      setStages(data);
    } catch (err) {
      console.error("Error fetching stages:", err);
      setError("Failed to load stages. Please try again later.");
    } finally {
      setIsLoading(false);
    }
  };

  const addStage = async (newStage: z.infer<typeof stageSchema>) => {
    try {
      const res = await fetch(`${API_BASE_URL}/stages/add-stage`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(newStage),
      });
      if (!res.ok) {
        throw new Error("Failed to create stage.");
      }
      fetchStages();
      return true;
    } catch (err) {
      console.error("Error creating stage:", err);
      setError("Failed to create stage. Please try again.");
      return false;
    }
  };

  const updateStage = async (id: string, updatedStage: z.infer<typeof stageSchema>) => {
    try {
      const res = await fetch(`${API_BASE_URL}/stages/update-stage/${id}`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(updatedStage),
      });
      if (!res.ok) {
        throw new Error("Failed to update stage.");
      }
      fetchStages();
      return true;
    } catch (err) {
      console.error("Error updating stage:", err);
      setError("Failed to update stage. Please try again.");
      return false;
    }
  };

  const deleteStage = async (id: string) => {
    try {
      const res = await fetch(`${API_BASE_URL}/stages/delete-stage/${id}`, {
        method: "DELETE",
      });
      if (!res.ok) {
        throw new Error("Failed to delete stage.");
      }
      fetchStages();
      return true;
    } catch (err) {
      console.error("Error deleting stage:", err);
      setError("Failed to delete stage. Please try again.");
      return false;
    }
  };

  useEffect(() => {
    fetchStages();
  }, []);

  return {
    stages,
    isLoading,
    error,
    addStage,
    updateStage,
    deleteStage,
    refetch: fetchStages
  };
};





frontend/app/hoooks/useProjectDetail.ts

// frontend/app/hooks/useProjectDetail.ts
import { useState, useEffect } from "react";
import { type ProjectEntry, type ProjectStageEntry, type StageEntry, type StageConnectionEntry } from "@/lib/schema";

const API_BASE_URL = "http://localhost:5000/api-v1";

export const useProjectDetail = (projectId: string | null) => {
  const [project, setProject] = useState<ProjectEntry | null>(null);
  const [stages, setStages] = useState<ProjectStageEntry[]>([]);
  const [connections, setConnections] = useState<StageConnectionEntry[]>([]);
  const [availableStages, setAvailableStages] = useState<StageEntry[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchProjectDetail = async () => {
    if (!projectId) return;
    
    setIsLoading(true);
    setError(null);
    
    try {
      // Fetch project details
      const projectRes = await fetch(`${API_BASE_URL}/projects/${projectId}`);
      if (!projectRes.ok) throw new Error("Failed to fetch project");
      const projectData = await projectRes.json();
      setProject(projectData);
      
      // Fetch project stages and sort by date
      if (projectData.stages) {
          // // Sort stages by date (oldest first)
        // const sortedStages = [...projectData.stages].sort((a, b) => {
        //   const dateA = new Date(a.start_date || a.created_at);
        //   const dateB = new Date(b.start_date || b.created_at);
        //   return dateA.getTime() - dateB.getTime();
        // });
        // setStages(sortedStages);

         // Sort stages by date (oldest first)
        const sortedStages = [...projectData.stages].sort((a, b) => {
          const dateA = a.start_date ? new Date(a.start_date).getTime() : Infinity;
          const dateB = b.start_date ? new Date(b.start_date).getTime() : Infinity;
          return dateA - dateB;
        });
        setStages(sortedStages);
      }
      
      // Fetch stage connections
      const connectionsRes = await fetch(`${API_BASE_URL}/projects/${projectId}/connections`);
      if (connectionsRes.ok) {
        const connectionsData = await connectionsRes.json();
        setConnections(connectionsData);
      }
      
      // Fetch all available stages
      const stagesRes = await fetch(`${API_BASE_URL}/stages/all-stages`);
      if (stagesRes.ok) {
        const allStages = await stagesRes.json();
        
        // Filter out stages already added to the project
        const addedStageIds = projectData.stages?.map((s: ProjectStageEntry) => s.stage._id) || [];
        const filteredStages = allStages.filter((stage: StageEntry) => 
          !addedStageIds.includes(stage._id)
        );
        
        setAvailableStages(filteredStages);
      }
    } catch (err) {
      console.error("Error fetching project detail:", err);
      setError("Failed to load project details. Please try again later.");
    } finally {
      setIsLoading(false);
    }
  };

  const updateProjectStatus = async (projectId: string, status: 'Pending' | 'Ongoing' | 'Completed' | 'Archived') => {
    try {
      const res = await fetch(`${API_BASE_URL}/projects/${projectId}`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ status }),
      });
      
      if (!res.ok) throw new Error("Failed to update project status");
      
      // Update the local project state
      if (project) {
        setProject({
          ...project,
          status
        });
      }
      
      return true;
    } catch (err) {
      console.error("Error updating project status:", err);
      setError("Failed to update project status. Please try again.");
      return false;
    }
  };

  const addStageToProject = async (stageId: string, status: 'Ongoing' | 'Completed', startDate?: string, completionDate?: string) => {
    if (!projectId) return;
    
    try {
      const res = await fetch(`${API_BASE_URL}/projects/${projectId}/stages`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          stageId,
          status,
          start_date: status === 'Ongoing' ? startDate : undefined,
          completion_date: status === 'Completed' ? completionDate : undefined
        }),
      });
      
      if (!res.ok) throw new Error("Failed to add stage to project");
      
      // Update project status based on the first stage added
      const stageData = await res.json();
      
      // If this is the first stage being added, update project status to 'Ongoing'
      if (stages.length === 0) {
        await updateProjectStatus(projectId, 'Ongoing');
      }
      
      // Refresh project data
      await fetchProjectDetail();
      return true;
    } catch (err) {
      console.error("Error adding stage to project:", err);
      setError("Failed to add stage to project. Please try again.");
      return false;
    }
  };

  const updateProjectStage = async (stageId: string, status: 'Ongoing' | 'Completed', startDate?: string, completionDate?: string) => {
    if (!projectId) return;
    
    try {
      const res = await fetch(`${API_BASE_URL}/projects/${projectId}/stages/${stageId}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          status,
          start_date: status === 'Ongoing' ? startDate : undefined,
          completion_date: status === 'Completed' ? completionDate : undefined
        }),
      });
      
      if (!res.ok) throw new Error("Failed to update project stage");
      
      // Refresh project data
      await fetchProjectDetail();
      return true;
    } catch (err) {
      console.error("Error updating project stage:", err);
      setError("Failed to update project stage. Please try again.");
      return false;
    }
  };

  const deleteProjectStage = async (stageId: string) => {
    if (!projectId) return;
    
    try {
      const res = await fetch(`${API_BASE_URL}/projects/${projectId}/stages/${stageId}`, {
        method: "DELETE",
      });
      
      if (!res.ok) throw new Error("Failed to delete project stage");
      
      // If this was the last stage being removed, update project status to 'Pending'
      if (stages.length === 1) {
        await updateProjectStatus(projectId, 'Pending');
      }
      
      // Refresh project data
      await fetchProjectDetail();
      return true;
    } catch (err) {
      console.error("Error deleting project stage:", err);
      setError("Failed to delete project stage. Please try again.");
      return false;
    }
  };

  const createStageConnection = async (fromStageId: string, toStageId: string) => {
    if (!projectId) return;
    
    try {
      const res = await fetch(`${API_BASE_URL}/projects/${projectId}/connections`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          fromStageId,
          toStageId
        }),
      });
      
      if (!res.ok) throw new Error("Failed to create stage connection");
      
      // Refresh project data
      await fetchProjectDetail();
      return true;
    } catch (err) {
      console.error("Error creating stage connection:", err);
      setError("Failed to create stage connection. Please try again.");
      return false;
    }
  };

  useEffect(() => {
    fetchProjectDetail();
  }, [projectId]);

  return {
    project,
    stages,
    connections,
    availableStages,
    isLoading,
    error,
    addStageToProject,
    updateProjectStage,
    deleteProjectStage,
    createStageConnection,
    refetch: fetchProjectDetail
  };
};











frontend/app/lib/index.ts
// frontend/app/lib/index.ts
import type { ProjectStatus } from "@/types";
export const publicRoutes = [
  "/",
  "/sign-in",
  "/sign-up",
  "/verify-email",
  "/reset-password",
  "/forgot-password",
  "*",
];
export const getTaskStatusColor = (status: ProjectStatus) => {
  switch (status) {
    case "In Progress":
      return "bg-blue-100 text-blue-800 dark:bg-blue-900/30 dark:text-blue-300";
    case "Completed":
      return "bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-300";
    case "Cancelled":
      return "bg-red-100 text-red-800 dark:bg-red-900/30 dark:text-red-300";
    case "On Hold":
      return "bg-yellow-100 text-yellow-800 dark:bg-yellow-900/30 dark:text-yellow-300";
    case "Planning":
      return "bg-purple-100 text-purple-800 dark:bg-purple-900/30 dark:text-purple-300";
    default:
      return "bg-gray-100 text-gray-800 dark:bg-gray-800 dark:text-gray-300";
  }
};
export const getProjectProgress = (tasks: { status: TaskStatus }[]) => {
  const totalTasks = tasks.length;
  const completedTasks = tasks.filter((task) => task?.status === "Done").length;
  const progress = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;
  return progress;
};





frontend/app/lib/schema.ts
// frontend/app/lib/schema.ts
import { z } from "zod";

export const signInSchema = z.object({
  email: z.string().email("Invalid email address"),
  password: z.string().min(6, "Password is required"),
});

export const signUpSchema = z
  .object({
    email: z.string().email("Invalid email address"),
    password: z.string().min(8, "Password must be 8 characters"),
    name: z.string().min(3, "Name must be at least 3 characters"),
    confirmPassword: z.string().min(8, "Password must be 8 characters"),
  })
  .refine((data) => data.password === data.confirmPassword, {
    path: ["confirmPassword"],
    message: "Passwords do not match",
  });

export const resetPasswordSchema = z
  .object({
    newPassword: z.string().min(8, "Password must be 8 characters"),
    confirmPassword: z.string().min(8, "Password must be 8 characters"),
  })
  .refine((data) => data.newPassword === data.confirmPassword, {
    path: ["confirmPassword"],
    message: "Passwords do not match",
  });

export const forgotPasswordSchema = z.object({
  email: z.string().email("Invalid email address"),
});

// Project schema
export const projectSchema = z.object({
  project_name: z.string().min(1, { message: "Project name is required" }),
  description: z.string().optional(),
  status: z.enum(['Pending', 'Ongoing', 'Completed', 'Archived']).optional(),
  created_at: z.string().min(1, { message: "Created at date is required" }),
});

export type ProjectEntry = z.infer<typeof projectSchema> & {
  _id: string;
  stages?: ProjectStageEntry[];
};

// Stage schema
export const stageSchema = z.object({
  stage_name: z.string().min(1, { message: "Stage name is required" }),
  description: z.string().optional(),
});

export type StageEntry = z.infer<typeof stageSchema> & {
  _id: string;
};

// Project Stage schema
export const projectStageSchema = z.object({
  status: z.enum(['Ongoing', 'Completed']),
  start_date: z.string().optional(),
  completion_date: z.string().optional(),
  order: z.number(),
});

export type ProjectStageEntry = z.infer<typeof projectStageSchema> & {
  _id: string;
  project: string;
  stage: StageEntry;
  connections?: StageConnectionEntry[];
};

// Stage Connection schema
export const stageConnectionSchema = z.object({
  from_stage: z.string(),
  to_stage: z.string(),
});

export type StageConnectionEntry = z.infer<typeof stageConnectionSchema> & {
  _id: string;
  project: string;
  from_stage: ProjectStageEntry;
  to_stage: ProjectStageEntry;
};

// Email schema
export const emailSchema = z.object({
  name: z.string().min(1, { message: "Name is required" }),
  email: z.string().email({ message: "Invalid email address" }),
});

export type EmailEntry = z.infer<typeof emailSchema> & {
  _id: string;
};








frontend/app/lib/fetch-util.ts
import axios from "axios";

const BASE_URL = import.meta.env.VITE_API_URL || "http://localhost:5000/api-v1";

const api = axios.create({
  baseURL: BASE_URL,
  headers: {
    "Content-Type": "application/json",
  },
});

api.interceptors.request.use((config) => {
  const token = localStorage.getItem("token");
  if (token) {
    config.headers.Authorization = `Bearer ${token ?? ""}`;
  }
  return config;
});

// Add a global handler for 401 errors
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response && error.response.status === 401) {
      // Dispatch a custom event to trigger logout in AuthProvider
      window.dispatchEvent(new Event("force-logout"));
    }
    return Promise.reject(error);
  }
);

const postData = async <T>(url: string, data: unknown): Promise<T> => {
  const response = await api.post(url, data);

  return response.data;
};

const updateData = async <T>(url: string, data: unknown): Promise<T> => {
  const response = await api.put(url, data);

  return response.data;
};

const fetchData = async <T>(url: string): Promise<T> => {
  const response = await api.get(url);

  return response.data;
};

const deleteData = async <T>(url: string): Promise<T> => {
  const response = await api.delete(url);

  return response.data;
};

export { postData, fetchData, updateData, deleteData };








frontend/app/routs/dashboard-layout.tsx
// frontend/app/component/routs/dashboard-layout.tsx
import { Header } from "@/components/layout/header";
import { SidebarComponent } from "@/components/layout/sidebar-component";
import { Loader } from "@/components/loader";
import { useAuth } from "@/provider/auth-context";
import { Navigate, Outlet, useLocation } from "react-router";
import { useState, useEffect } from "react";

const DashboardLayout = () => {
  const { isAuthenticated, isLoading } = useAuth();
  const location = useLocation();
  const [selectedProject, setSelectedProject] = useState<any>(null);
  
  if (isLoading) {
    return <Loader />;
  }
  
  if (!isAuthenticated) {
    return <Navigate to="/sign-in" state={{ from: location }} replace />;
  }
  
  const handleProjectSelect = (project: any) => {
    console.log("DashboardLayout handleProjectSelect:", project); // Debug log
    setSelectedProject(project);
  };
  
  // Only pass the project selection context on the dashboard page
  const isDashboard = location.pathname === '/dashboard';
  
  return (
    <div className="flex h-screen w-full">
      <SidebarComponent />
      <div className="flex flex-1 flex-col h-full">
        <Header 
          onProjectSelect={isDashboard ? handleProjectSelect : undefined} 
          selectedProject={isDashboard ? selectedProject : undefined} 
        />
        <main className="flex-1 overflow-y-auto h-full w-full">
          <div className="mx-auto container px-2 sm:px-6 lg:px-8 py-0 md:py-8 w-full h-full">
            <Outlet context={{ selectedProject: isDashboard ? selectedProject : null }} />
          </div>
        </main>
      </div>
    </div>
  );
};

export default DashboardLayout;








frontend/app/routs/dashboard/index.tsx
import Dashboard from "../../components/dashboard/Dashboard";

// The DashboardLayout will already be rendered by the router.
// This component only needs to render its specific content.
export default function DashboardPage() {
  return <Dashboard />;
}





frontend/app/routs/emails/index.tsx
import EmailManagement from "../../components/emails/email-management";
// The DashboardLayout will already be rendered by the router.
// This component only needs to render its specific content.
export default function EmailsPage() {
  return <EmailManagement />;
}




frontend/app/routs/projects/$projectId.tsx
// frontend/routes/projects/$projectId.tsx
import { useParams } from "react-router-dom";
import { ProjectDetail } from "../../components/projects/ProjectDetail";
export default function ProjectDetailRoute() {
  const { projectId } = useParams<{ projectId: string }>();
  
  if (!projectId) {
    return <div>Project ID is required</div>;
  }
  
  return <ProjectDetail />;
}







frontend/app/routs/projects/index.tsx
// frontend/routes/projects/index.tsx
import ProjectManagement from "../../components/projects/project-management";
export default function ProjectsPage() {
  return <ProjectManagement />;
}




frontend/app/routs/root/home.tsx
import React from "react";
import type { Route } from "../../+types/root";
import { Button } from "@/components/ui/button";
import { Link } from "react-router";

export function meta({}: Route.MetaArgs) {
  return [
    { title: "TaskHub" },
    { name: "description", content: "Welcome to TaskHub!" },
  ];
}

const Homepage = () => {
  return (
    <div className="w-full h-screen flex items-center justify-center gap-4">
      <Link to="/sign-in">
        <Button className="bg-blue-500 text-white">Login</Button>
      </Link>
      <Link to="/sign-up">
        <Button variant="outline" className="bg-blue-500 text-white">
          Sign Up
        </Button>
      </Link>
    </div>
  );
};

export default Homepage;











frontend/app/routs/stages/index.tsx
import StageManagement from "../../components/stages/stage-management";
export default function StagesPage() {
  return <StageManagement />;
}







frontend/app/types/index.ts
export interface User {
  _id: string;
  email: string;
  name: string;
  createdAt: Date;
  isEmailVerified: boolean;
  updatedAt: Date;
  profilePicture?: string;
}


export enum ProjectStatus {

  IN_PROGRESS = "In Progress",
  COMPLETED = "Completed",
}

// Project types
export interface Project {
  _id: string;
  project_name: string;
  description: string;
  status: 'Pending' | 'Ongoing' | 'Completed' | 'Archived';
  created_at: string;
  updated_at: string | null;
  owner: {
    _id: string;
    name: string;
    email: string;
  };
}

// Form types
export interface ProjectFormData {
  project_name: string;
  description: string;
  created_at: string;
}

// API response types
export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
}

// Auth types
export interface AuthState {
  user: User | null;
  token: string | null;
  isAuthenticated: boolean;
}

export interface Subtask {
  _id: string;
  title: string;
  completed: boolean;
  createdAt: Date;
}



export interface Attachment {
  fileName: string;
  fileUrl: string;
  fileType: string;
  fileSize: number;
  uploadedBy: string;
  uploadedAt: Date;
  _id: string;
}

e

export type ResourceType =
  | "Project"
  | "User";


export interface StatsCardProps {
  totalProjects: number;
  totalTasks: number;
  totalProjectInProgress: number;
  totalTaskCompleted: number;
  totalTaskToDo: number;
  totalTaskInProgress: number;
}



export interface ProjectStatusData {
  name: string;
  value: number;
  color: string;
}









frontend/app/root.tsx
// frontend/app/root.tsx
import {
  isRouteErrorResponse,
  Links,
  Meta,
  Outlet,
  Scripts,
  ScrollRestoration,
} from "react-router";

import type { Route } from "./+types/root";
import "./app.css";
import ReactQueryProvider from "./provider/react-query-provider";
import { TooltipProvider } from "./components/ui/tooltip";

export const links: Route.LinksFunction = () => [
  { rel: "preconnect", href: "https://fonts.googleapis.com" },
  {
    rel: "preconnect",
    href: "https://fonts.gstatic.com",
    crossOrigin: "anonymous",
  },
  {
    rel: "stylesheet",
    href: "https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap",
  },
];

export function Layout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <Meta />
        <Links />
      </head>
      <body>
        {children}
        <ScrollRestoration />
        <Scripts />
      </body>
    </html>
  );
}

export default function App() {
  return (
    <TooltipProvider>
      <ReactQueryProvider>
        <Outlet />
      </ReactQueryProvider>
    </TooltipProvider>
  );
}

export function ErrorBoundary({ error }: Route.ErrorBoundaryProps) {
  let message = "Oops!";
  let details = "An unexpected error occurred.";
  let stack: string | undefined;

  if (isRouteErrorResponse(error)) {
    message = error.status === 404 ? "404" : "Error";
    details =
      error.status === 404
        ? "The requested page could not be found."
        : error.statusText || details;
  } else if (import.meta.env.DEV && error && error instanceof Error) {
    details = error.message;
    stack = error.stack;
  }

  return (
    <main className="pt-16 p-4 container mx-auto">
      <h1>{message}</h1>
      <p>{details}</p>
      {stack && (
        <pre className="w-full p-4 overflow-x-auto">
          <code>{stack}</code>
        </pre>
      )}
    </main>
  );
}





















































frontend/app/component/dashboard/Dashboard.tsx
// frontend/app/component/dashboard/Dashboard.tsx
import React, { useState, useEffect } from "react";
import { StatsCard } from "./StatsCard";
import { ProjectStatusChart } from "./ProjectStatusChart";
import { ProjectCountOverTime } from "./ProjectCountOverTime";
import { ProjectStageInfo } from "./ProjectStageInfo";
import { StageTimeTracking } from "./StageTimeTracking";
import { RecentProjects } from "./RecentProjects"; // Import the new component
import { useDashboard, type TimePeriod } from "@/hooks/useDashboard";
import { useOutletContext } from "react-router-dom";
import { 
  FolderKanban, 
  Clock, 
  CheckCircle, 
  ListTodo, 
  Loader2,
  TrendingUp,
  Calendar,
  AlertCircle,
  BarChart3
} from "lucide-react";
import { format, subMonths, startOfMonth, endOfMonth, eachMonthOfInterval, getYear } from "date-fns";
import { useProjects } from "@/hooks/use-projects";

interface DashboardContext {
  selectedProject: any;
}

const Dashboard = () => {
  const { selectedProject } = useOutletContext<DashboardContext>();
  const [timePeriod, setTimePeriod] = useState<TimePeriod>({
    type: 'month',
    value: new Date().getFullYear().toString()
  });
  
  // Get all projects, not filtered by time period
  const { projects, isLoading, error, fetchProjects, refetch } = useProjects();
  const [localSelectedProject, setLocalSelectedProject] = useState(selectedProject);
  
  // Use the useDashboard hook with all projects for the stats cards
  const {
    totalProjects,
    ongoingProjects,
    completedProjects,
    pendingProjects,
    totalStages,
    ongoingStages,
    completedStages,
    projectStatusData,
    recentProjects,
    upcomingStages,
    isLoading: dashboardLoading
  } = useDashboard(undefined, projects); // Pass undefined as time period to get all projects
  
  // Handle project selection
  const handleProjectSelect = (project: any) => {
    console.log("Dashboard handleProjectSelect:", project); // Debug log
    setLocalSelectedProject(project);
  };
  
  // Handle time period change with useCallback to prevent unnecessary re-renders
  const handleTimePeriodChange = React.useCallback((period: TimePeriod) => {
    setTimePeriod(period);
    console.log("Time period changed to:", period); // Debug log
  }, []);
  
  if (dashboardLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }
  
  if (error) {
    return (
      <div className="flex flex-col items-center justify-center h-64 space-y-4">
        <div className="text-center">
          <h2 className="text-xl font-semibold text-red-600 mb-2">Error Loading Dashboard</h2>
          <p className="text-gray-600">{error}</p>
        </div>
        <button 
          onClick={() => refetch()}
          className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors"
        >
          Try Again
        </button>
      </div>
    );
  }
  
  return (
    <div className="space-y-6">
      <div className="flex flex-col md:flex-row md:items-center justify-between gap-4">
        <h1 className="text-2xl font-bold">Dashboard</h1>
        
        {/* <div className="text-sm text-gray-500">
          {timePeriod.type === 'year' 
            ? `Showing data for ${timePeriod.value === 'all' ? 'all years' : timePeriod.value}` 
            : `Showing data for ${timePeriod.value}`}
        </div> */}
      </div>
      
      {/* Stats Cards */}
      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
        <StatsCard
          title="Total Projects"
          value={totalProjects}
          icon={FolderKanban}
          filterType="all"
        />
        <StatsCard
          title="Ongoing Projects"
          value={ongoingProjects}
          icon={Clock}
          description="Currently in progress"
          filterType="ongoing"
        />
        <StatsCard
          title="Completed Projects"
          value={completedProjects}
          icon={CheckCircle}
          description="Successfully finished"
          filterType="completed"
        />
        <StatsCard
          title="Pending Projects"
          value={pendingProjects}
          icon={AlertCircle}
          description="Not started yet"
          filterType="pending"
        />
      </div>
      
      {/* Charts and Project Info */}
      <div className="grid gap-4 md:grid-cols-2">
        <ProjectStatusChart data={projectStatusData} />
        <ProjectStageInfo 
          project={localSelectedProject} 
          onProjectSelect={handleProjectSelect} 
        />
      </div>
      
      {/* Recent Projects and Time-based Charts */}
      <div className="grid gap-4 md:grid-cols-2">
        <RecentProjects projects={recentProjects} /> {/* Add the RecentProjects component */}
        <ProjectCountOverTime 
          projects={projects} // Pass all projects, not filtered ones
          onTimePeriodChange={handleTimePeriodChange} 
        />
      </div>
      
      {/* Additional Time-based Chart */}
      <div className="grid gap-4 md:grid-cols-1">
        <StageTimeTracking 
          projects={recentProjects} 
          selectedProjectId={localSelectedProject?._id} 
        />
      </div>
    </div>
  );
};

export default Dashboard;






frontend/app/component/dashboard/ProjectCountOverTime.tsx
// frontend/app/component/dashboard/ProjectCountOverTime.tsx
import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Button } from "@/components/ui/button";
import { Calendar, CalendarDays } from "lucide-react";
import { format, subYears, startOfYear, endOfYear, startOfMonth, endOfMonth, eachMonthOfInterval, getYear } from "date-fns";
import { useProjects } from "@/hooks/use-projects";

interface ProjectCountData {
  name: string;
  projects: number;
}

export interface TimePeriod {
  type: 'year' | 'month';
  value: string;
}

interface ProjectCountOverTimeProps {
  projects: any[];
  onTimePeriodChange: (period: TimePeriod) => void;
}

export const ProjectCountOverTime: React.FC<ProjectCountOverTimeProps> = ({ 
  projects, 
  onTimePeriodChange 
}) => {
  const [timeRange, setTimeRange] = useState<'year' | 'month'>('year');
  const [selectedYear, setSelectedYear] = useState<string>('');
  const [availableYears, setAvailableYears] = useState<string[]>([]);
  const [dimensions, setDimensions] = React.useState({ width: 400, height: 300 });
  const { fetchProjectYears } = useProjects();
  
  // Extract unique years from the projects data
  useEffect(() => {
    if (projects && projects.length > 0) {
      const years = new Set<string>();
      projects.forEach(project => {
        if (project.created_at) {
          const projectDate = new Date(project.created_at);
          years.add(projectDate.getFullYear().toString());
        }
      });
      
      const sortedYears = Array.from(years).sort((a, b) => parseInt(b) - parseInt(a));
      setAvailableYears(sortedYears);
      
      // Set the initial selected year to the most recent year if not already set
      if (!selectedYear && sortedYears.length > 0) {
        setSelectedYear(sortedYears[0]);
      }
    }
  }, [projects, selectedYear]);
  
  // Process projects data based on selected time range - memoized to prevent recalculation
  const chartData = useMemo(() => {
    if (!projects.length || !availableYears.length) {
      return [];
    }
    
    let data: ProjectCountData[] = [];
    
    if (timeRange === 'year') {
      // Show project count per year for all available years
      const years = availableYears.map(year => parseInt(year));
      
      data = years.map(year => {
        const yearStart = startOfYear(new Date(year, 0, 1));
        const yearEnd = endOfYear(new Date(year, 0, 1));
        
        const count = projects.filter(project => {
          const projectDate = new Date(project.created_at);
          return projectDate >= yearStart && projectDate <= yearEnd;
        }).length;
        
        return {
          name: year.toString(),
          projects: count
        };
      });
    } else {
      // Show project count per month for the selected year
      if (!selectedYear) return [];
      
      const year = parseInt(selectedYear);
      const yearStart = startOfYear(new Date(year, 0, 1));
      const yearEnd = endOfYear(new Date(year, 0, 1));
      const months = eachMonthOfInterval({ start: yearStart, end: yearEnd });
      
      data = months.map(month => {
        const monthStart = startOfMonth(month);
        const monthEnd = endOfMonth(month);
        
        const count = projects.filter(project => {
          const projectDate = new Date(project.created_at);
          return projectDate >= monthStart && projectDate <= monthEnd;
        }).length;
        
        return {
          name: format(month, 'MMM'),
          projects: count
        };
      });
    }
    
    return data;
  }, [projects, timeRange, selectedYear, availableYears]);
  
  // Handle time range change - memoized to prevent unnecessary re-renders
  const handleTimeRangeChange = useCallback((value: 'year' | 'month') => {
    setTimeRange(value);
    // Create a properly typed period object
    const period: TimePeriod = { 
      type: value, 
      value: value === 'year' ? 'all' : (selectedYear || availableYears[0])
    };
    onTimePeriodChange(period);
  }, [onTimePeriodChange, selectedYear, availableYears]);
  
  // Handle year change - memoized to prevent unnecessary re-renders
  const handleYearChange = useCallback((value: string) => {
    setSelectedYear(value);
    // Create a properly typed period object
    const period: TimePeriod = { 
      type: 'month', 
      value
    };
    onTimePeriodChange(period);
  }, [onTimePeriodChange]);
  
  return (
    <Card className="w-full h-full flex flex-col overflow-hidden">
      <CardHeader className="pb-2 flex-shrink-0">
        <div className="flex flex-col space-y-4">
          <CardTitle className="text-base sm:text-lg md:text-xl flex items-center gap-2">
            <CalendarDays className="h-4 w-4 sm:h-5 sm:w-5 text-blue-600 flex-shrink-0" />
            <span className="truncate">Projects Over Time</span>
          </CardTitle>
          
          <div className="flex flex-wrap gap-2">
            <Select value={timeRange} onValueChange={handleTimeRangeChange}>
              <SelectTrigger className="w-full sm:w-auto">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="year">By Year</SelectItem>
                <SelectItem value="month">By Month</SelectItem>
              </SelectContent>
            </Select>
            {timeRange === 'month' && (
              <Select value={selectedYear} onValueChange={handleYearChange}>
                <SelectTrigger className="w-full sm:w-auto">
                  <SelectValue placeholder="Select a year" />
                </SelectTrigger>
                <SelectContent>
                  {availableYears.map(year => (
                    <SelectItem key={year} value={year}>
                      {year}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            )}
          </div>
        </div>
      </CardHeader>
      <CardContent className="p-1 sm:p-2 md:p-4 flex-grow flex flex-col overflow-hidden">
        <div className="h-full w-full min-h-[200px]">
          {chartData.length > 0 ? (
            <ResponsiveContainer width="100%" height="100%">
              <LineChart
                data={chartData}
                margin={{
                  top: 5,
                  right: 5,
                  left: 5,
                  bottom: dimensions.width < 400 ? 25 : 5,
                }}
              >
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis 
                  dataKey="name" 
                  tick={{ fontSize: dimensions.width < 400 ? 8 : dimensions.width < 640 ? 10 : 12 }}
                  angle={dimensions.width < 640 ? -45 : 0}
                  textAnchor={dimensions.width < 640 ? "end" : "middle"}
                  height={dimensions.width < 640 ? 40 : 30}
                  interval={0}
                />
                <YAxis 
                  tick={{ fontSize: dimensions.width < 400 ? 8 : dimensions.width < 640 ? 10 : 12 }} 
                  width={dimensions.width < 400 ? 25 : 30} 
                />
                <Tooltip 
                  formatter={(value) => [`${value} projects`, 'Count']}
                  labelFormatter={(label) => `Period: ${label}`}
                />
                <Legend 
                  iconSize={dimensions.width < 400 ? 8 : 10}
                  iconType="circle"
                  wrapperStyle={{
                    fontSize: dimensions.width < 400 ? '8px' : dimensions.width < 640 ? '10px' : '12px',
                    paddingTop: '5px'
                  }}
                />
                <Line 
                  type="linear" 
                  dataKey="projects" 
                  stroke="#8884d8" 
                  activeDot={{ r: dimensions.width < 400 ? 4 : 6 }}
                  name="Projects"
                  strokeWidth={dimensions.width < 400 ? 1 : 1.5}
                />
              </LineChart>
            </ResponsiveContainer>
          ) : (
            <div className="flex items-center justify-center h-full text-gray-500">
              <div className="text-center">
                <p className="mb-2 text-sm md:text-base">No project data available</p>
                <p className="text-xs md:text-sm">Create projects to see trends over time</p>
              </div>
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
};








frontend/app/component/dashboard/ProjectSearchDropdown.tsx

// frontend/app/component/dashboard/ProjectSearchDropdown.tsx
import React, { useState, useEffect, useRef } from 'react';
import { Search, ChevronDown } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Card, CardContent } from "@/components/ui/card";
import { useProjects } from "@/hooks/use-projects";

interface ProjectSearchDropdownProps {
  onProjectSelect: (project: any) => void;
  selectedProject?: any;
}

export const ProjectSearchDropdown: React.FC<ProjectSearchDropdownProps> = ({ 
  onProjectSelect, 
  selectedProject 
}) => {
  const { projects } = useProjects();
  const [searchTerm, setSearchTerm] = useState('');
  const [isOpen, setIsOpen] = useState(false);
  const [filteredProjects, setFilteredProjects] = useState<any[]>([]);
  const dropdownRef = useRef<HTMLDivElement>(null);
  
  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };
    
    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);
  
  // Filter projects based on search term
  useEffect(() => {
    if (!searchTerm) {
      // Show all projects when no search term
      setFilteredProjects(projects);
      return;
    }
    
    const term = searchTerm.toLowerCase();
    const filtered = projects.filter(project =>
      project.project_name.toLowerCase().includes(term) ||
      (project.description && project.description.toLowerCase().includes(term))
    );
    
    setFilteredProjects(filtered);
  }, [searchTerm, projects]);
  
  const handleProjectClick = (project: any) => {
    onProjectSelect(project);
    setIsOpen(false);
    setSearchTerm('');
  };
  
  const clearSelection = () => {
    onProjectSelect(null);
    setSearchTerm('');
  };
  
  const getStatusColor = (status?: string) => {
    switch (status) {
      case 'Pending': return 'bg-yellow-100 text-yellow-800';
      case 'Ongoing': return 'bg-blue-100 text-blue-800';
      case 'Completed': return 'bg-green-100 text-green-800';
      case 'Archived': return 'bg-gray-100 text-gray-800';
      default: return 'bg-gray-100 text-gray-800';
    }
  };

  return (
    <div className="w-full max-w-md" ref={dropdownRef}>
      <div className="relative">
        <div className="flex gap-2">
          <div className="relative flex-1">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 h-4 w-4" />
            <Input
              placeholder="Search projects..."
              value={selectedProject ? selectedProject.project_name : searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              onFocus={() => setIsOpen(true)}
              className="pl-10 pr-10"
            />
            {selectedProject && (
              <Button
                variant="ghost"
                size="sm"
                className="absolute right-1 top-1/2 transform -translate-y-1/2 h-6 w-6 p-0"
                onClick={clearSelection}
              >
                
              </Button>
            )}
          </div>
          <Button 
            variant="outline" 
            onClick={() => setIsOpen(!isOpen)}
            className="flex items-center gap-1"
          >
            Select
            <ChevronDown className={`h-4 w-4 transition-transform ${isOpen ? 'rotate-180' : ''}`} />
          </Button>
        </div>
        
        {isOpen && (
          <Card className="absolute z-10 w-full mt-1 shadow-lg">
            <CardContent className="p-0">
              <div className="max-h-80 overflow-y-auto">
                {filteredProjects.length === 0 ? (
                  <div className="p-4 text-center text-gray-500">
                    No projects found
                  </div>
                ) : (
                  <div className="py-1">
                    {filteredProjects.map((project) => (
                      <div
                        key={project._id}
                        className="px-4 py-3 hover:bg-gray-100 cursor-pointer border-b border-gray-100 last:border-b-0"
                        onClick={() => handleProjectClick(project)}
                      >
                        <div className="flex justify-between items-start">
                          <div className="flex-1 min-w-0">
                            <div className="font-medium break-words">{project.project_name}</div>
                            {project.description && (
                              <div className="text-sm text-gray-500 mt-1 break-words">
                                {project.description}
                              </div>
                            )}
                            <div className="text-xs text-gray-400 mt-1">
                              Created: {new Date(project.created_at).toLocaleDateString()}
                            </div>
                          </div>
                          <div className="ml-2 flex-shrink-0">
                            <span className={`text-xs px-2 py-1 rounded-full ${getStatusColor(project.status)}`}>
                              {project.status}
                            </span>
                          </div>
                        </div>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            </CardContent>
          </Card>
        )}
      </div>
    </div>
  );
};






frontend/app/component/dashboard/ProjectStageInfo.tsx

// frontend/app/component/dashboard/ProjectStageInfo.tsx
import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { CheckCircle, Clock, AlertCircle, ListTodo } from "lucide-react";
import { ProjectSearchDropdown } from "./ProjectSearchDropdown";
import { useStages } from "@/hooks/use-stages";
import { type ProjectEntry } from "@/lib/schema";

interface ProjectStageInfoProps {
  project: ProjectEntry | null;
  onProjectSelect: (project: any) => void;
}

export const ProjectStageInfo: React.FC<ProjectStageInfoProps> = ({ 
  project, 
  onProjectSelect 
}) => {
  const { stages: allStages } = useStages();
  
  // Calculate project progress based on all stages in the system
  const calculateProjectProgress = () => {
    if (!project || !project.stages || project.stages.length === 0) {
      return 0;
    }
    
    // Total stages in the system
    const totalStagesInSystem = allStages.length;
    
    // Stages added to this project
    const stagesInProject = project.stages.length;
    
    // Calculate progress as percentage of total stages in system
    return Math.round((stagesInProject / totalStagesInSystem) * 100);
  };
  
  const progressPercentage = calculateProjectProgress();
  
  if (!project) {
    return (
      <Card className="col-span-1">
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <AlertCircle className="h-5 w-5 text-yellow-600" />
            Project Stage Information
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {/* Project Search Dropdown */}
            <div>
              <h3 className="text-sm font-medium mb-2">Select a Project</h3>
              <ProjectSearchDropdown 
                onProjectSelect={onProjectSelect} 
                selectedProject={null} 
              />
            </div>
            
            {/* All Stages Summary */}
            <div className="bg-blue-50 p-4 rounded-lg">
              <div className="flex items-center gap-2 mb-2">
                <ListTodo className="h-5 w-5 text-blue-600" />
                <span className="font-medium">All Stages in System</span>
              </div>
              <div className="text-3xl font-bold text-blue-600">{allStages.length}</div>
              <div className="text-sm text-gray-600 mt-1">
                Total stages available across all projects
              </div>
            </div>
            
            <div className="flex flex-col items-center justify-center py-8 text-center text-gray-500">
              <AlertCircle className="h-12 w-12 mb-4 text-gray-400" />
              <p className="mb-2">No project selected</p>
              <p className="text-sm">Select a project from the dropdown to view stage information</p>
            </div>
          </div>
        </CardContent>
      </Card>
    );
  }
  
  // Calculate stage statistics
  const totalStages = project.stages?.length || 0;
  const completedStages = project.stages?.filter(stage => stage.status === 'Completed').length || 0;
  const remainingStages = totalStages - completedStages;
  const completionPercentage = totalStages > 0 ? Math.round((completedStages / totalStages) * 100) : 0;
  
  const getStatusColor = (status?: string) => {
    switch (status) {
      case 'Pending': return 'bg-yellow-100 text-yellow-800';
      case 'Ongoing': return 'bg-blue-100 text-blue-800';
      case 'Completed': return 'bg-green-100 text-green-800';
      case 'Archived': return 'bg-gray-100 text-gray-800';
      default: return 'bg-gray-100 text-gray-800';
    }
  };
  
  return (
    <Card className="col-span-1">
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <ListTodo className="h-5 w-5 text-green-600" />
          Project Stage Information
        </CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          {/* Project Search Dropdown */}
          <div>
            <h3 className="text-sm font-medium mb-2">Select a Project</h3>
            <ProjectSearchDropdown 
              onProjectSelect={onProjectSelect} 
              selectedProject={project} 
            />
          </div>
          
          {/* All Stages Summary */}
          <div className="bg-blue-50 p-4 rounded-lg">
            <div className="flex items-center gap-2 mb-2">
              <ListTodo className="h-5 w-5 text-blue-600" />
              <span className="font-medium">All Stages in System</span>
            </div>
            <div className="text-3xl font-bold text-blue-600">{allStages.length}</div>
            <div className="text-sm text-gray-600 mt-1">
              Total stages available across all projects
            </div>
          </div>
          
          <div className="flex items-center justify-between">
            <h3 className="text-lg font-semibold truncate">{project.project_name}</h3>
            <Badge className={getStatusColor(project.status)}>
              {project.status}
            </Badge>
          </div>
          
          <div className="grid grid-cols-2 gap-4">
            <div className="bg-blue-50 p-4 rounded-lg">
              <div className="flex items-center gap-2 mb-2">
                <CheckCircle className="h-5 w-5 text-blue-600" />
                <span className="font-medium">Total Stages</span>
              </div>
              <div className="text-3xl font-bold text-blue-600">{totalStages}</div>
            </div>
            
            <div className="bg-green-50 p-4 rounded-lg">
              <div className="flex items-center gap-2 mb-2">
                <CheckCircle className="h-5 w-5 text-green-600" />
                <span className="font-medium">Completed Stages</span>
              </div>
              <div className="text-3xl font-bold text-green-600">{completedStages}</div>
              <div className="text-sm text-gray-600 mt-1">
                {completionPercentage}% of project stages
              </div>
            </div>
          </div>
          
          <div className="mt-4">
            <div className="flex justify-between text-sm mb-1">
              <span>Project Progress (vs All Stages)</span>
              <span>{progressPercentage}%</span>
            </div>
            <div className="w-full bg-gray-200 rounded-full h-2.5">
              <div 
                className="bg-green-600 h-2.5 rounded-full" 
                style={{ width: `${progressPercentage}%` }}
              ></div>
            </div>
            <div className="text-xs text-gray-500 mt-1">
              {totalStages} of {allStages.length} total stages added to this project
            </div>
          </div>
          
          <div className="mt-4">
            <div className="flex justify-between text-sm mb-1">
              <span>Stage Completion Progress</span>
              <span>{completionPercentage}%</span>
            </div>
            <div className="w-full bg-gray-200 rounded-full h-2.5">
              <div 
                className="bg-blue-600 h-2.5 rounded-full" 
                style={{ width: `${completionPercentage}%` }}
              ></div>
            </div>
          </div>
          
          <div className="mt-4 text-sm text-gray-600">
            <p>Remaining Stages: {remainingStages}</p>
            <p>Created: {new Date(project.created_at).toLocaleDateString()}</p>
          </div>
        </div>
      </CardContent>
    </Card>
  );
};







frontend/app/component/dashboard/ProjectStatusChart.tsx
// frontend/app/component/dashboard/ProjectStatusChart.tsx
import React, { useRef, useState, useEffect } from 'react';
import { PieChart, Pie, Cell, ResponsiveContainer, Tooltip, Legend } from 'recharts';
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";

interface ProjectStatusData {
  name: string;
  value: number;
  color: string;
}

interface ProjectStatusChartProps {
  data: ProjectStatusData[];
}

const SOFT_COLORS = [
  '#8884d8', // Soft purple
  '#82ca9d', // Soft green
  '#ffc658', // Soft yellow
  '#ff8042', // Soft orange
];

export const ProjectStatusChart: React.FC<ProjectStatusChartProps> = ({ data }) => {
  const hasData = data.some(item => item.value > 0);
  const filteredData = data.filter(item => item.value > 0);

  const containerRef = useRef<HTMLDivElement>(null);
  const [containerWidth, setContainerWidth] = useState(300);
  const [showLabels, setShowLabels] = useState(true);

  useEffect(() => {
    const handleResize = () => {
      if (containerRef.current) {
        setContainerWidth(containerRef.current.offsetWidth);
        setShowLabels(containerRef.current.offsetWidth > 200);
      }
    };
    handleResize();
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return (
    <Card className="w-full h-full flex flex-col overflow-hidden">
      <CardHeader className="pb-2 flex-shrink-0">
        <CardTitle className="text-base sm:text-lg md:text-xl">
          Project Status Distribution
        </CardTitle>
      </CardHeader>
      <CardContent
        ref={containerRef}
        className="p-1 sm:p-2 md:p-4 flex-grow flex flex-col overflow-hidden"
      >
        <div className="h-full w-full min-h-[200px]">
          {hasData ? (
            <ResponsiveContainer width="100%" height="100%">
              <PieChart margin={{ top: 20, right: 20, left: 20, bottom: showLabels ? 60 : 20 }}>
                <Pie
                  data={filteredData}
                  cx="50%"
                  cy="50%"
                  labelLine={showLabels}
                  outerRadius={showLabels ? "65%" : "75%"}
                  fill="#8884d8"
                  dataKey="value"
                  label={showLabels ? ({ name, percent, x, y }) => {
                    const fontSize = Math.max(Math.min(containerWidth / 20, 14), 8);
                    const maxLength = containerWidth < 250 ? 6 : 10;
                    const displayName =
                      name.length > maxLength ? `${name.substring(0, maxLength)}` : name;
                    return (
                      <text
                        x={x}
                        y={y}
                        fill="#000"
                        fontSize={fontSize}
                        textAnchor="middle"
                        dominantBaseline="central"
                      >
                        {`${displayName}: ${(percent * 100).toFixed(0)}%`}
                      </text>
                    );
                  } : false}
                  minAngle={15}
                >
                  {filteredData.map((entry, index) => (
                    <Cell
                      key={`cell-${index}`}
                      fill={entry.color || SOFT_COLORS[index % SOFT_COLORS.length]}
                    />
                  ))}
                </Pie>
                <Tooltip formatter={(value) => [`${value} projects`, 'Count']} />
                <Legend
                  layout="horizontal"
                  verticalAlign="bottom"
                  align="center"
                  iconSize={10}
                  iconType="circle"
                  wrapperStyle={{
                    fontSize: '10px',
                    paddingTop: '5px',
                    paddingBottom: '10px'
                  }}
                />
              </PieChart>
            </ResponsiveContainer>
          ) : (
            <div className="flex items-center justify-center h-full text-gray-500">
              <div className="text-center">
                <p className="mb-2 text-sm md:text-base">No project data available</p>
                <p className="text-xs md:text-sm">Create projects to see status distribution</p>
              </div>
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
};









frontend/app/component/dashboard/RecentProject.tsx
import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { format } from "date-fns";
import { useNavigate } from "react-router-dom";
import { type ProjectEntry } from "@/lib/schema";

interface RecentProjectsProps {
  projects: ProjectEntry[];
}

const getStatusBadgeClass = (status?: string) => {
  switch (status) {
    case 'Pending': return 'bg-yellow-100 text-yellow-800';
    case 'Ongoing': return 'bg-blue-100 text-blue-800';
    case 'Completed': return 'bg-green-100 text-green-800';
    case 'Archived': return 'bg-gray-100 text-gray-800';
    default: return 'bg-gray-100 text-gray-800';
  }
};

export const RecentProjects: React.FC<RecentProjectsProps> = ({ projects }) => {
  const navigate = useNavigate();
  
  const formatDisplayDate = (dateString: string) => {
    try {
      return format(new Date(dateString), "MMM dd, yyyy");
    } catch (error) {
      return dateString;
    }
  };

  const handleProjectClick = (projectId: string) => {
    navigate(`/projects/${projectId}`);
  };

  return (
    <Card className="col-span-1">
      <CardHeader>
        <CardTitle>Recent Projects</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          {projects.length === 0 ? (
            <div className="flex flex-col items-center justify-center py-8 text-center text-gray-500">
              <p className="mb-2">No projects found</p>
              <p className="text-sm">Create your first project to get started</p>
            </div>
          ) : (
            projects.map((project) => (
              <div 
                key={project._id} 
                className="flex items-center justify-between p-3 rounded-lg border border-gray-100 hover:bg-gray-50 cursor-pointer transition-colors"
                onClick={() => handleProjectClick(project._id)}
              >
                <div className="space-y-1 flex-1 min-w-0">
                  <p className="text-sm font-medium leading-none truncate">
                    {project.project_name}
                  </p>
                  <p className="text-xs text-muted-foreground">
                    Created: {formatDisplayDate(project.created_at)}
                  </p>
                </div>
                <Badge className={getStatusBadgeClass(project.status)}>
                  {project.status}
                </Badge>
              </div>
            ))
          )}
        </div>
      </CardContent>
    </Card>
  );
};










frontend/app/component/dashboard/StageTimeTracking.jsx

// frontend/app/component/dashboard/StageTimeTracking.tsx
import React, { useState, useEffect } from 'react';
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Clock, Timer } from "lucide-react";
import { format, differenceInDays } from "date-fns";

interface StageTimeData {
  name: string;
  days: number;
}

interface StageTimeTrackingProps {
  projects: any[];
  selectedProjectId?: string;
}

export const StageTimeTracking: React.FC<StageTimeTrackingProps> = ({ 
  projects, 
  selectedProjectId 
}) => {
  const [chartData, setChartData] = useState<StageTimeData[]>([]);
  const [selectedProject, setSelectedProject] = useState<string>(selectedProjectId || 'all');
  
  // Get all projects with stages for the dropdown
  const projectOptions = [
    { value: 'all', label: 'All Projects' },
    ...projects.map(project => ({
      value: project._id,
      label: project.project_name
    }))
  ];
  
  // Process stages data to calculate completion times
  useEffect(() => {
    const allStages: any[] = [];
    
    // Collect all stages from projects
    projects.forEach(project => {
      if (project.stages && Array.isArray(project.stages)) {
        project.stages.forEach((stage: any) => {
          // Only include completed stages with both start and completion dates
          if (stage.status === 'Completed' && stage.start_date && stage.completion_date) {
            allStages.push({
              ...stage,
              project_name: project.project_name,
              project_id: project._id
            });
          }
        });
      }
    });
    
    // Filter by selected project if not 'all'
    const filteredStages = selectedProject === 'all' 
      ? allStages 
      : allStages.filter(stage => stage.project_id === selectedProject);
    
    // Calculate completion time in days for each stage
    const stageTimeData = filteredStages.map(stage => {
      const startDate = new Date(stage.start_date);
      const completionDate = new Date(stage.completion_date);
      const days = differenceInDays(completionDate, startDate);
      
      return {
        name: stage.stage.stage_name,
        days: days > 0 ? days : 1, // Ensure at least 1 day
        project: stage.project_name
      };
    });
    
    // Sort by days (ascending)
    stageTimeData.sort((a, b) => a.days - b.days);
    
    setChartData(stageTimeData);
  }, [projects, selectedProject]);
  
  const handleProjectChange = (value: string) => {
    setSelectedProject(value);
  };
  
  return (
    <Card className="col-span-1">
      <CardHeader>
        <div className="flex flex-col space-y-4">
          <CardTitle className="flex items-center gap-2">
            <Timer className="h-5 w-5 text-purple-600" />
            Stage Completion Time
          </CardTitle>
          
          <div className="w-full">
            <Select value={selectedProject} onValueChange={handleProjectChange}>
              <SelectTrigger className="w-full">
                <SelectValue placeholder="Select a project" />
              </SelectTrigger>
              <SelectContent>
                {projectOptions.map(option => (
                  <SelectItem key={option.value} value={option.value} className="max-w-xs">
                    <div className="break-words">{option.label}</div>
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </div>
      </CardHeader>
      <CardContent className="h-80">
        {chartData.length > 0 ? (
          <ResponsiveContainer width="100%" height="100%">
            <BarChart
              data={chartData}
              margin={{
                top: 5,
                right: 30,
                left: 20,
                bottom: 5,
              }}
            >
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="name" />
              <YAxis label={{ value: 'Days', angle: -90, position: 'insideLeft' }} />
              <Tooltip 
                formatter={(value) => [`${value} days`, 'Completion Time']}
                labelFormatter={(label) => `Stage: ${label}`}
              />
              <Legend />
              <Bar 
                dataKey="days" 
                fill="#8884d8" 
                name="Days to Complete"
              />
            </BarChart>
          </ResponsiveContainer>
        ) : (
          <div className="flex items-center justify-center h-full text-gray-500">
            <div className="text-center">
              <Timer className="h-12 w-12 mb-4 text-gray-400" />
              <p className="mb-2">No stage completion data available</p>
              <p className="text-sm">Complete some project stages to see completion times</p>
            </div>
          </div>
        )}
      </CardContent>
    </Card>
  );
};





frontend/app/component/dashboard/StatsCard.tsx


// frontend/app/component/dashboard/StatsCard.tsx
import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { useNavigate } from "react-router-dom";

interface StatsCardProps {
  title: string;
  value: number | string;
  description?: string;
  icon: any;
  trend?: {
    value: number;
    isPositive: boolean;
  };
  className?: string;
  color?: string;
  filterType?: 'all' | 'ongoing' | 'completed' | 'pending';
  onClick?: () => void;
}

export const StatsCard: React.FC<StatsCardProps> = ({
  title,
  value,
  description,
  icon: Icon,
  trend,
  className,
  color = "bg-blue-50",
  filterType,
  onClick
}) => {
  const navigate = useNavigate();
  
  const handleClick = () => {
    if (onClick) {
      onClick();
      return;
    }
    
    if (filterType) {
      // Navigate to projects page with filter
      // For "all", use "all" directly, for others use proper case (first letter capitalized)
      const filterValue = filterType === 'all' ? 'all' : filterType.charAt(0).toUpperCase() + filterType.slice(1);
      console.log(`Navigating to /projects?filter=${filterValue}`); // Debug log
      navigate(`/projects?filter=${filterValue}`);
    }
  };

  const getCardColor = () => {
    switch (filterType) {
      case 'ongoing': return 'bg-blue-50 hover:bg-blue-100 border-blue-200';
      case 'completed': return 'bg-green-50 hover:bg-green-100 border-green-200';
      case 'pending': return 'bg-yellow-50 hover:bg-yellow-100 border-yellow-200';
      default: return `${color} hover:bg-gray-100`;
    }
  };

  const getIconColor = () => {
    switch (filterType) {
      case 'ongoing': return 'text-blue-600';
      case 'completed': return 'text-green-600';
      case 'pending': return 'text-yellow-600';
      default: return 'text-gray-600';
    }
  };

  const getBadgeColor = () => {
    switch (filterType) {
      case 'ongoing': return 'bg-blue-100 text-blue-800';
      case 'completed': return 'bg-green-100 text-green-800';
      case 'pending': return 'bg-yellow-100 text-yellow-800';
      default: return 'bg-gray-100 text-gray-800';
    }
  };

  return (
    <Card 
      className={`cursor-pointer transition-all duration-200 ${getCardColor()} ${className}`}
      onClick={handleClick}
    >
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle className="text-sm font-medium flex items-center gap-2">
          {title}
          {filterType && (
            <Badge className={getBadgeColor()}>
              {filterType}
            </Badge>
          )}
        </CardTitle>
        <Icon className={`h-5 w-5 ${getIconColor()}`} />
      </CardHeader>
      <CardContent>
        <div className="text-3xl font-bold">{value}</div>
        {description && (
          <p className="text-xs text-muted-foreground mt-1">
            {description}
          </p>
        )}
        {trend && (
          <div className={`flex items-center text-xs mt-1 ${trend.isPositive ? 'text-green-600' : 'text-red-600'}`}>
            <span>{trend.isPositive ? '' : ''} {Math.abs(trend.value)}%</span>
            <span className="ml-1">from last month</span>
          </div>
        )}
      </CardContent>
    </Card>
  );
};






frontend/app/component/layout/header.tsx
// frontend/app/component/layout/header.tsx
import { useAuth } from "@/provider/auth-context";
import { Button } from "../ui/button";
import { Bell } from "lucide-react";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuTrigger,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuItem,
} from "../ui/dropdown-menu";
import { Avatar, AvatarImage, AvatarFallback } from "../ui/avatar";
import { Link, useNavigate } from "react-router";
import { BarChart3 } from "lucide-react";
import { memo } from "react";

interface HeaderProps {
  onProjectSelect?: (project: any) => void;
  selectedProject?: any;
}

// Memoize the Header component to prevent unnecessary re-renders
const HeaderComponent = memo(({ onProjectSelect, selectedProject }: HeaderProps) => {
  const navigate = useNavigate();
  const { user, logout } = useAuth();
  
  return (
    <div className="bg-background sticky top-0 z-40 border-b">
      <div className="flex h-14 items-center justify-between px-4 sm:px-6 lg:px-8 py-4">
        <div className="flex items-center">
          <BarChart3 className="h-6 w-6 text-blue-600 mr-2" />
          <h1 className="text-xl font-bold">Project Management Dashboard</h1>
        </div>
        
        <div className="flex items-center gap-4">
          <Button variant="ghost" size="icon">
            <Bell />
          </Button>
          
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <button className="rounded-full border p-1 w-8 h-8">
                <Avatar className="w-8 h-8">
                  <AvatarImage src={user?.profilePicture} alt={user?.name} />
                  <AvatarFallback className="bg-primary text-primary-foreground">
                    {user?.name?.charAt(0).toUpperCase()}
                  </AvatarFallback>
                </Avatar>
              </button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuLabel>My Account</DropdownMenuLabel>
              <DropdownMenuSeparator />
              <DropdownMenuItem>
                <Link to="/user/profile">Profile</Link>
              </DropdownMenuItem>
              <DropdownMenuSeparator />
              <DropdownMenuItem onClick={logout}>Log Out</DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      </div>
    </div>
  );
});

HeaderComponent.displayName = 'Header';

// Export the component with the name 'Header'
export { HeaderComponent as Header };








// frontend/app/component/routs/dashboard-layout.tsx
// frontend/app/component/routs/dashboard-layout.tsx
import { Header } from "@/components/layout/header";
import { SidebarComponent } from "@/components/layout/sidebar-component";
import { Loader } from "@/components/loader";
import { useAuth } from "@/provider/auth-context";
import { Navigate, Outlet, useLocation } from "react-router";
import { useState, useEffect } from "react";

const DashboardLayout = () => {
  const { isAuthenticated, isLoading } = useAuth();
  const location = useLocation();
  const [selectedProject, setSelectedProject] = useState<any>(null);
  
  if (isLoading) {
    return <Loader />;
  }
  
  if (!isAuthenticated) {
    return <Navigate to="/sign-in" state={{ from: location }} replace />;
  }
  
  const handleProjectSelect = (project: any) => {
    console.log("DashboardLayout handleProjectSelect:", project); // Debug log
    setSelectedProject(project);
  };
  
  // Only pass the project selection context on the dashboard page
  const isDashboard = location.pathname === '/dashboard';
  
  return (
    <div className="flex h-screen w-full">
      <SidebarComponent />
      <div className="flex flex-1 flex-col h-full">
        <Header 
          onProjectSelect={isDashboard ? handleProjectSelect : undefined} 
          selectedProject={isDashboard ? selectedProject : undefined} 
        />
        <main className="flex-1 overflow-y-auto h-full w-full">
          <div className="mx-auto container px-2 sm:px-6 lg:px-8 py-0 md:py-8 w-full h-full">
            <Outlet context={{ selectedProject: isDashboard ? selectedProject : null }} />
          </div>
        </main>
      </div>
    </div>
  );
};

export default DashboardLayout;













// frontend/app/hooks/useDashboard.ts
// frontend/app/hooks/useDashboard.ts
import { useState, useEffect, useCallback } from "react";
import { useProjects } from "./use-projects";
import { useStages } from "./use-stages";
import { type ProjectEntry, type StageEntry, type ProjectStageEntry } from "@/lib/schema";
import { format, startOfYear, endOfYear, startOfMonth, endOfMonth, isWithinInterval, getYear, getMonth } from "date-fns";

export interface TimePeriod {
  type: 'year' | 'month';
  value: string;
}

export const useDashboard = (timePeriod?: TimePeriod, projects?: ProjectEntry[]) => {
  const { isLoading: projectsLoading, error: projectsError } = useProjects();
  const { stages: allStages, isLoading: stagesLoading, error: stagesError } = useStages();
  
  const [dashboardData, setDashboardData] = useState<{
    totalProjects: number;
    ongoingProjects: number;
    completedProjects: number;
    pendingProjects: number;
    totalStages: number;
    ongoingStages: number;
    completedStages: number;
    projectStatusData: any[];
    recentProjects: ProjectEntry[];
    upcomingStages: ProjectStageEntry[];
  }>({
    totalProjects: 0,
    ongoingProjects: 0,
    completedProjects: 0,
    pendingProjects: 0,
    totalStages: 0,
    ongoingStages: 0,
    completedStages: 0,
    projectStatusData: [],
    recentProjects: [],
    upcomingStages: []
  });
  
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  // Process data when projects or stages change
  const processData = useCallback(() => {
    try {
      // Use the projects passed as parameter if available, otherwise use the ones from the hook
      const projectsToUse = projects || [];
      
      // Calculate statistics
      const totalProjects = projectsToUse.length;
      const ongoingProjects = projectsToUse.filter(p => p.status === 'Ongoing').length;
      const completedProjects = projectsToUse.filter(p => p.status === 'Completed').length;
      const pendingProjects = projectsToUse.filter(p => p.status === 'Pending').length;
      
      // Get all project stages from all projects
      const allProjectStages: ProjectStageEntry[] = [];
      projectsToUse.forEach(project => {
        if (project.stages && Array.isArray(project.stages)) {
          project.stages.forEach(stage => {
            // Ensure stage has the required properties
            if (stage && stage._id && stage.status) {
              allProjectStages.push(stage as ProjectStageEntry);
            }
          });
        }
      });
      
      const totalStages = allProjectStages.length;
      const ongoingStages = allProjectStages.filter(s => s.status === 'Ongoing').length;
      const completedStages = allProjectStages.filter(s => s.status === 'Completed').length;
      
      // Project status data for pie chart
      const statusCounts = {
        'Pending': pendingProjects,
        'Ongoing': ongoingProjects,
        'Completed': completedProjects,
        'Archived': projectsToUse.filter(p => p.status === 'Archived').length
      };
      
      const projectStatusData = [
        { name: 'Pending', value: statusCounts.Pending, color: '#FFBB28' },
        { name: 'Ongoing', value: statusCounts.Ongoing, color: '#0088FE' },
        { name: 'Completed', value: statusCounts.Completed, color: '#00C49F' },
        { name: 'Archived', value: statusCounts.Archived, color: '#FF8042' }
      ];
      
      // Recent projects (last 5)
      const sortedProjects = [...projectsToUse]
        .sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime())
        .slice(0, 5);
      
      // Upcoming stages (ongoing stages sorted by start date)
      const sortedStages = [...allProjectStages]
        .filter(stage => stage.status === 'Ongoing')
        .sort((a, b) => {
          const dateA = a.start_date ? new Date(a.start_date).getTime() : Infinity;
          const dateB = b.start_date ? new Date(b.start_date).getTime() : Infinity;
          return dateA - dateB;
        })
        .slice(0, 5);
      
      setDashboardData({
        totalProjects,
        ongoingProjects,
        completedProjects,
        pendingProjects,
        totalStages,
        ongoingStages,
        completedStages,
        projectStatusData,
        recentProjects: sortedProjects,
        upcomingStages: sortedStages
      });
      
      setIsLoading(false);
    } catch (err) {
      console.error("Error processing dashboard data:", err);
      setError("Failed to process dashboard data");
      setIsLoading(false);
    }
  }, [projects]);
  
  // Process data when projects or stages loading state changes
  useEffect(() => {
    if (!projectsLoading && !stagesLoading) {
      processData();
    }
  }, [projectsLoading, stagesLoading, processData]);
  
  // Combine errors
  useEffect(() => {
    if (projectsError || stagesError) {
      setError(projectsError || stagesError || "An error occurred");
    }
  }, [projectsError, stagesError]);
  
  return {
    ...dashboardData,
    isLoading: isLoading || projectsLoading || stagesLoading,
    error,
    refetch: processData
  };
};












// frontend/app/hooks/use-project.ts
// frontend/app/hooks/use-projects.ts
import { useState, useEffect, useCallback } from "react";
import { type ProjectEntry, projectSchema } from "@/lib/schema";
import { z } from "zod";

const API_BASE_URL = "http://localhost:5000/api-v1";

export const useProjects = () => {
  const [projects, setProjects] = useState<ProjectEntry[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // Memoize fetchProjects to prevent unnecessary re-renders
  const fetchProjects = useCallback(async (filters?: { year?: string; month?: string }) => {
    setIsLoading(true);
    setError(null);
    try {
      // Build query string from filters
      const queryParams = new URLSearchParams();
      
      // Only add year filter if it's not "all" and not empty
      if (filters?.year && filters.year !== 'all') {
        queryParams.append('year', filters.year);
      }
      
      if (filters?.month) {
        queryParams.append('month', filters.month);
      }
      
      const queryString = queryParams.toString();
      const url = `${API_BASE_URL}/projects/all-projects${queryString ? `?${queryString}` : ''}`;
      
      console.log("Fetching projects from:", url); // Debug log
      
      const res = await fetch(url);
      if (!res.ok) {
        const errorData = await res.json();
        throw new Error(errorData.message || "Failed to fetch projects.");
      }
      const data = await res.json();
      console.log("Projects data received:", data); // Debug log
      setProjects(data);
    } catch (err) {
      console.error("Error fetching projects:", err);
      setError(err instanceof Error ? err.message : "Failed to load projects. Please try again later.");
    } finally {
      setIsLoading(false);
    }
  }, []);
  
  // New function to fetch available years
  const fetchProjectYears = useCallback(async () => {
    try {
      const res = await fetch(`${API_BASE_URL}/projects/project-years`);
      if (!res.ok) {
        throw new Error("Failed to fetch project years.");
      }
      const data = await res.json();
      return data;
    } catch (err) {
      console.error("Error fetching project years:", err);
      setError(err instanceof Error ? err.message : "Failed to fetch project years.");
      return [];
    }
  }, []);
  
  const createProject = useCallback(async (newProject: z.infer<typeof projectSchema>) => {
    try {
      const res = await fetch(`${API_BASE_URL}/projects/project`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(newProject),
      });
      if (!res.ok) {
        throw new Error("Failed to create project.");
      }
      await fetchProjects();
    } catch (err) {
      console.error("Error creating project:", err);
      setError("Failed to create project. Please try again.");
    }
  }, [fetchProjects]);
  
  // Update to handle partial updates
  const updateProject = useCallback(async (id: string, updatedProject: Partial<z.infer<typeof projectSchema>>) => {
    try {
      const res = await fetch(`${API_BASE_URL}/projects/${id}`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(updatedProject),
      });
      if (!res.ok) {
        throw new Error("Failed to update project.");
      }
      await fetchProjects();
    } catch (err) {
      console.error("Error updating project:", err);
      setError("Failed to update project. Please try again.");
    }
  }, [fetchProjects]);
  
  const deleteProject = useCallback(async (id: string) => {
    try {
      const res = await fetch(`${API_BASE_URL}/projects/delete-project/${id}`, {
        method: "DELETE",
      });
      if (!res.ok) {
        throw new Error("Failed to delete project.");
      }
      await fetchProjects();
    } catch (err) {
      console.error("Error deleting project:", err);
      setError("Failed to delete project. Please try again.");
    }
  }, [fetchProjects]);
  
  // Initial fetch on mount
  useEffect(() => {
    fetchProjects();
  }, [fetchProjects]);
  
  return {
    projects,
    isLoading,
    error,
    createProject,
    updateProject,
    deleteProject,
    fetchProjects,
    fetchProjectYears,
    refetch: fetchProjects
  };
};












backend/controller/project.js
// backend/controllers/project.js
import Project from "../models/project.js";
import ProjectStage from "../models/projectStage.js";
import StageConnection from "../models/stageConnection.js";

// Helper function to create a Date object at noon to avoid timezone issues
const createLocalDate = (dateString) => {
  if (!dateString) return null;
  const date = new Date(dateString);
  // Set time to noon to avoid DST issues
  date.setHours(12, 0, 0, 0);
  return date;
};

// Helper function to format date as YYYY-MM-DD in local timezone
const formatDateToLocal = (date) => {
  if (!date) return null;
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
};

// Create a new project
export const createProject = async (req, res) => {
  try {
    const { project_name, description, status, created_at } = req.body;
    
    // Create a Date object at noon to avoid timezone issues
    const createdAtDate = createLocalDate(created_at);
    
    const newProject = new Project({
      project_name,
      description,
      status: status || "Pending",
      created_at: createdAtDate
    });
    
    await newProject.save();
    res.status(201).json({ success: true, project: newProject });
  } catch (err) {
    console.error(err.message);
    res.status(500).json({ success: false, error: "Server error" });
  }
};

// Get all projects
export const getAllProjects = async (req, res) => {
  try {
    const { year, month } = req.query;
    
    let query = {};
    
    // Filter by year if provided and not "all"
    if (year && year !== "all") {
      const yearNum = parseInt(year);
      if (!isNaN(yearNum)) {
        const startDate = new Date(yearNum, 0, 1); // January 1st of the year
        const endDate = new Date(yearNum + 1, 0, 1); // January 1st of the next year
        
        query.created_at = {
          $gte: startDate,
          $lt: endDate
        };
      }
    }
    
    // Filter by month if provided (year must also be provided)
    if (year && month && year !== "all") {
      const yearNum = parseInt(year);
      const monthNum = parseInt(month) - 1; // JavaScript months are 0-indexed
      if (!isNaN(yearNum) && !isNaN(monthNum)) {
        const startDate = new Date(yearNum, monthNum, 1); // First day of the month
        const endDate = new Date(yearNum, monthNum + 1, 1); // First day of the next month
        
        query.created_at = {
          $gte: startDate,
          $lt: endDate
        };
      }
    }
    
    console.log("Query for projects:", query); // Debug log
    
    const projects = await Project.find(query)
      .populate({
        path: 'stages',
        populate: {
          path: 'stage',
          model: 'Stage'
        }
      })
      .sort({ created_at: -1 }); // Sort by creation date, newest first
    
    // Format dates to YYYY-MM-DD for frontend in local timezone
    const formattedProjects = projects.map(project => {
      const formattedProject = project.toObject();
      formattedProject.created_at = formatDateToLocal(project.created_at);
      
      // Format stage dates
      if (formattedProject.stages && formattedProject.stages.length > 0) {
        formattedProject.stages = formattedProject.stages.map(stage => {
          const formattedStage = { ...stage };
          if (stage.start_date) {
            formattedStage.start_date = formatDateToLocal(stage.start_date);
          }
          if (stage.completion_date) {
            formattedStage.completion_date = formatDateToLocal(stage.completion_date);
          }
          return formattedStage;
        });
      }
      
      return formattedProject;
    });
    
    console.log("Formatted projects:", formattedProjects); // Debug log
    
    res.status(200).json(formattedProjects);
  } catch (error) {
    console.error("Error fetching projects:", error);
    res.status(500).json({ message: "Error fetching projects", error: error.message });
  }
};

// Get available years from projects
export const getProjectYears = async (req, res) => {
  try {
    // Get distinct years from project creation dates
    const projects = await Project.find({}, { created_at: 1 });
    const yearsSet = new Set();
    
    projects.forEach(project => {
      if (project.created_at) {
        const year = new Date(project.created_at).getFullYear();
        yearsSet.add(year);
      }
    });
    
    const years = Array.from(yearsSet).sort((a, b) => b - a); // Sort in descending order
    
    console.log("Available years:", years); // Debug log
    
    res.status(200).json(years);
  } catch (error) {
    console.error("Error fetching project years:", error);
    res.status(500).json({ message: "Error fetching project years", error: error.message });
  }
};

// Keep other functions unchanged...
// Get a single project with stages
export const getProjectById = async (req, res) => {
  try {
    const { id } = req.params;
    
    const project = await Project.findById(id)
      .populate({
        path: 'stages',
        populate: {
          path: 'stage',
          model: 'Stage'
        }
      });
    
    if (!project) {
      return res.status(404).json({ message: "Project not found" });
    }
    
    // Format dates
    const formattedProject = {
      ...project.toObject(),
      created_at: formatDateToLocal(project.created_at),
      stages: project.stages.map(stage => ({
        ...stage.toObject(),
        start_date: formatDateToLocal(stage.start_date),
        completion_date: formatDateToLocal(stage.completion_date)
      }))
    };
    
    res.status(200).json(formattedProject);
  } catch (error) {
    console.error("Error fetching project:", error);
    res.status(500).json({ message: "Error fetching project", error });
  }
};

// Update a project
export const updateProject = async (req, res) => {
  const { id } = req.params;
  const { project_name, description, status, created_at } = req.body;
  
  try {
    console.log("Updating project:", { id, project_name, description, status, created_at });
    
    // Build update object dynamically based on provided fields
    const updateData = {};
    if (project_name) updateData.project_name = project_name;
    if (description !== undefined) updateData.description = description;
    if (status) updateData.status = status;
    if (created_at) {
      // Create a Date object at noon to avoid timezone issues
      updateData.created_at = createLocalDate(created_at);
    }
    
    const updatedProject = await Project.findByIdAndUpdate(
      id,
      updateData,
      { new: true }
    ).populate({
      path: 'stages',
      populate: {
        path: 'stage',
        model: 'Stage'
      }
    });
    
    if (!updatedProject) {
      return res.status(404).json({ message: "Project not found" });
    }
    
    // Format date to YYYY-MM-DD for frontend in local timezone
    const formattedProject = {
      ...updatedProject.toObject(),
      created_at: formatDateToLocal(updatedProject.created_at)
    };
    
    res.status(200).json(formattedProject);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Error updating project", error });
  }
};

// Delete a project
export const deleteProject = async (req, res) => {
  const { id } = req.params;
  
  try {
    // Delete all project stages and connections
    await ProjectStage.deleteMany({ project: id });
    await StageConnection.deleteMany({ project: id });
    
    const deletedProject = await Project.findByIdAndDelete(id);
    
    if (!deletedProject) {
      return res.status(404).json({ message: "Project not found" });
    }
    
    res.status(200).json({ message: "Project deleted successfully" });
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Error deleting project", error });
  }
};

// Add a stage to a project
export const addStageToProject = async (req, res) => {
  try {
    const { projectId } = req.params;
    const { stageId, status, start_date, completion_date } = req.body;
    
    // Check if project exists
    const project = await Project.findById(projectId);
    if (!project) {
      return res.status(404).json({ message: "Project not found" });
    }
    
    // Get the current highest order number
    const highestOrderStage = await ProjectStage.findOne({ project: projectId })
      .sort({ order: -1 });
    
    const order = highestOrderStage ? highestOrderStage.order + 1 : 1;
    
    // Create new project stage
    const newProjectStage = new ProjectStage({
      project: projectId,
      stage: stageId,
      status,
      start_date: status === 'Ongoing' ? createLocalDate(start_date) : undefined,
      completion_date: status === 'Completed' ? createLocalDate(completion_date) : undefined,
      order
    });
    
    await newProjectStage.save();
    
    // Add stage to project
    project.stages.push(newProjectStage._id);
    await project.save();
    
    // Populate stage details
    const populatedStage = await ProjectStage.findById(newProjectStage._id)
      .populate('stage');
    
    // Format dates
    const formattedStage = {
      ...populatedStage.toObject(),
      start_date: formatDateToLocal(populatedStage.start_date),
      completion_date: formatDateToLocal(populatedStage.completion_date)
    };
    
    res.status(201).json(formattedStage);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Error adding stage to project", error });
  }
};

// Update a project stage
export const updateProjectStage = async (req, res) => {
  try {
    const { projectId, stageId } = req.params;
    const { status, start_date, completion_date } = req.body;
    
    const projectStage = await ProjectStage.findOne({ 
      _id: stageId, 
      project: projectId 
    });
    
    if (!projectStage) {
      return res.status(404).json({ message: "Project stage not found" });
    }
    
    // Update fields
    if (status) projectStage.status = status;
    if (start_date) projectStage.start_date = createLocalDate(start_date);
    if (completion_date) projectStage.completion_date = createLocalDate(completion_date);
    
    await projectStage.save();
    
    // Populate stage details
    const populatedStage = await ProjectStage.findById(projectStage._id)
      .populate('stage');
    
    // Format dates
    const formattedStage = {
      ...populatedStage.toObject(),
      start_date: formatDateToLocal(populatedStage.start_date),
      completion_date: formatDateToLocal(populatedStage.completion_date)
    };
    
    res.status(200).json(formattedStage);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Error updating project stage", error });
  }
};

// Delete a project stage
export const deleteProjectStage = async (req, res) => {
  try {
    const { projectId, stageId } = req.params;
    
    const projectStage = await ProjectStage.findOne({ 
      _id: stageId, 
      project: projectId 
    });
    
    if (!projectStage) {
      return res.status(404).json({ message: "Project stage not found" });
    }
    
    // Delete all connections related to this stage
    await StageConnection.deleteMany({ 
      $or: [
        { from_stage: stageId },
        { to_stage: stageId }
      ]
    });
    
    // Remove stage from project
    await Project.findByIdAndUpdate(projectId, {
      $pull: { stages: stageId }
    });
    
    // Delete the stage
    await ProjectStage.findByIdAndDelete(stageId);
    
    res.status(200).json({ message: "Project stage deleted successfully" });
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Error deleting project stage", error });
  }
};

// Create a connection between stages
export const createStageConnection = async (req, res) => {
  try {
    const { projectId } = req.params;
    const { fromStageId, toStageId } = req.body;
    
    // Check if both stages exist and belong to the project
    const fromStage = await ProjectStage.findOne({ 
      _id: fromStageId, 
      project: projectId 
    });
    
    const toStage = await ProjectStage.findOne({ 
      _id: toStageId, 
      project: projectId 
    });
    
    if (!fromStage || !toStage) {
      return res.status(404).json({ message: "One or both stages not found" });
    }
    
    // Check if connection already exists
    const existingConnection = await StageConnection.findOne({
      from_stage: fromStageId,
      to_stage: toStageId,
      project: projectId
    });
    
    if (existingConnection) {
      return res.status(400).json({ message: "Connection already exists" });
    }
    
    // Create new connection
    const newConnection = new StageConnection({
      from_stage: fromStageId,
      to_stage: toStageId,
      project: projectId
    });
    
    await newConnection.save();
    
    // Add connection to both stages
    fromStage.connections.push(newConnection._id);
    toStage.connections.push(newConnection._id);
    
    await fromStage.save();
    await toStage.save();
    
    res.status(201).json(newConnection);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Error creating stage connection", error });
  }
};

// Get all connections for a project
export const getProjectStageConnections = async (req, res) => {
  try {
    const { projectId } = req.params;
    
    const connections = await StageConnection.find({ project: projectId })
      .populate({
        path: 'from_stage',
        populate: {
          path: 'stage',
          model: 'Stage'
        }
      })
      .populate({
        path: 'to_stage',
        populate: {
          path: 'stage',
          model: 'Stage'
        }
      });
    
    res.status(200).json(connections);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "Error fetching stage connections", error });
  }
};



backend/routs/project.js
// backend/routes/project.js
import express from "express";
import {
  createProject,
  getAllProjects,
  getProjectById,
  updateProject,
  deleteProject,
  addStageToProject,
  updateProjectStage,
  deleteProjectStage,
  createStageConnection,
  getProjectStageConnections,
  getProjectYears
} from "../controllers/project.js";

const router = express.Router();

// These routes should match what the frontend is calling
router.post("/project", createProject);
router.get("/all-projects", getAllProjects);
router.get("/project-years", getProjectYears); // Add this route
router.get("/:id", getProjectById);
router.put("/:id", updateProject);
router.delete("/delete-project/:id", deleteProject);
router.post("/:projectId/stages", addStageToProject);
router.put("/:projectId/stages/:stageId", updateProjectStage);
router.delete("/:projectId/stages/:stageId", deleteProjectStage);
router.post("/:projectId/connections", createStageConnection);
router.get("/:projectId/connections", getProjectStageConnections);

export default router;


also keep this for furthear































frontend/app/hooks/use-auth.ts

import { postData } from "@/lib/fetch-util";
import type { SignupFormData } from "@/routes/auth/sign-up";
import { useMutation } from "@tanstack/react-query";
export const useSignUpMutation = () => {
  return useMutation({
    mutationFn: (data: SignupFormData) => postData("/auth/register", data),
  });
};
export const useVerifyEmailMutation = () => {
  return useMutation({
    mutationFn: (data: { token: string }) =>
      postData("/auth/verify-email", data),
  });
};
export const useLoginMutation = () => {
  return useMutation({
    mutationFn: (data: { email: string; password: string }) =>
      postData("/auth/login", data),
  });
};
export const useForgotPasswordMutation = () => {
  return useMutation({
    mutationFn: (data: { email: string }) =>
      postData("/auth/reset-password-request", data),
  });
};
export const useResetPasswordMutation = () => {
  return useMutation({
    mutationFn: (data: {
      token: string;
      newPassword: string;
      confirmPassword: string;
    }) => postData("/auth/reset-password", data),
  });
};
frontend/app/hooks/use-user.ts

import { fetchData, updateData } from "@/lib/fetch-util";
import type {
  ChangePasswordFormData,
  ProfileFormData,
} from "@/routes/user/profile";
import { useMutation, useQuery, type QueryKey } from "@tanstack/react-query";
const queryKey: QueryKey = ["user"];
export const useUserProfileQuery = () => {
  return useQuery({
    queryKey,
    queryFn: () => fetchData("/users/profile"),
  });
};
export const useChangePassword = () => {
  return useMutation({
    mutationFn: (data: ChangePasswordFormData) =>
      updateData("/users/change-password", data),
  });
};
export const useUpdateUserProfile = () => {
  return useMutation({
    mutationFn: (data: ProfileFormData) => updateData("/users/profile", data),
  });
};


frontend/app/routs/auth/auth-layout.tsx
import { useAuth } from "@/provider/auth-context";
import React from "react";
import { Navigate, Outlet } from "react-router";
const AuthLayout = () => {
  const { isAuthenticated, isLoading } = useAuth();
  if (isLoading) {
    return <div>Loading...</div>;
  }
  if (isAuthenticated) {
    return <Navigate to="/dashboard" />;
  }
  return <Outlet />;
};
export default AuthLayout;

frontend/app/routs/auth/forgot-password.tsx
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { useForgotPasswordMutation } from "@/hooks/use-auth";
import { forgotPasswordSchema } from "@/lib/schema";
import { zodResolver } from "@hookform/resolvers/zod";
import { ArrowLeft, CheckCircle, Loader2 } from "lucide-react";
import React, { useState } from "react";
import { useForm } from "react-hook-form";
import { Link } from "react-router";
import { toast } from "sonner";
import type { z } from "zod";
type ForgotPasswordFormData = z.infer<typeof forgotPasswordSchema>;
const ForgotPassword = () => {
  const [isSuccess, setIsSuccess] = useState(false);
  const { mutate: forgotPassword, isPending } = useForgotPasswordMutation();
  const form = useForm<ForgotPasswordFormData>({
    resolver: zodResolver(forgotPasswordSchema),
    defaultValues: {
      email: "",
    },
  });
  const onSubmit = (data: ForgotPasswordFormData) => {
    forgotPassword(data, {
      onSuccess: () => {
        setIsSuccess(true);
      },
      onError: (error: any) => {
        const errorMessage = error.response?.data?.message;
        console.log(error);
        toast.error(errorMessage);
      },
    });
  };
  return (
    <div className="flex flex-col items-center justify-center h-screen">
      <div className="w-full max-w-md space-y-6">
        <div className="flex flex-col items-center justify-center space-y-2">
          <h1 className="text-2xl font-bold">Forgot Password</h1>
          <p className="text-muted-foreground">
            Enter your email to reset your password
          </p>
        </div>
        <Card>
          <CardHeader>
            <Link to="/sign-in" className="flex items-center gap-2">
              <ArrowLeft className="w-4 h-4" />
              <span>Back to sign in</span>
            </Link>
          </CardHeader>
          <CardContent>
            {isSuccess ? (
              <div className="flex flex-col items-center justify-center">
                <CheckCircle className="w-10 h-10 text-green-500" />
                <h1 className="text-2xl font-bold">
                  Password reset email sent
                </h1>
                <p className="text-muted-foreground">
                  Check your email for a link to reset your password
                </p>
              </div>
            ) : (
              <>
                <Form {...form}>
                  <form
                    onSubmit={form.handleSubmit(onSubmit)}
                    className="space-y-4"
                  >
                    <FormField
                      name="email"
                      control={form.control}
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Email Address</FormLabel>
                          <FormControl>
                            <Input {...field} placeholder="Enter your email" />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <Button
                      type="submit"
                      className="w-full"
                      disabled={isPending}
                    >
                      {isPending ? (
                        <Loader2 className="w-4 h-4 animate-spin" />
                      ) : (
                        "Reset Password"
                      )}
                    </Button>
                  </form>
                </Form>
              </>
            )}
          </CardContent>
        </Card>
      </div>
    </div>
  );
};
export default ForgotPassword;

frontend/app/routs/auth/reset-password.tsx
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { useResetPasswordMutation } from "@/hooks/use-auth";
import { resetPasswordSchema } from "@/lib/schema";
import { zodResolver } from "@hookform/resolvers/zod";
import { ArrowBigDown, ArrowLeft, CheckCircle, Loader2 } from "lucide-react";
import React, { useState } from "react";
import { useForm } from "react-hook-form";
import { Link, useSearchParams } from "react-router";
import { toast } from "sonner";
import { z } from "zod";
type ResetPasswordFormData = z.infer<typeof resetPasswordSchema>;
const ResetPassword = () => {
  const [searchParams] = useSearchParams();
  const token = searchParams.get("token");
  const [isSuccess, setIsSuccess] = useState(false);
  const { mutate: resetPassword, isPending } = useResetPasswordMutation();
  const form = useForm<ResetPasswordFormData>({
    resolver: zodResolver(resetPasswordSchema),
    defaultValues: {
      newPassword: "",
      confirmPassword: "",
    },
  });
  const onSubmit = (values: ResetPasswordFormData) => {
    if (!token) {
      toast.error("Invalid token");
      return;
    }
    resetPassword(
      { ...values, token: token as string },
      {
        onSuccess: () => {
          setIsSuccess(true);
        },
        onError: (error: any) => {
          const errorMessage = error.response?.data?.message;
          toast.error(errorMessage);
          console.log(error);
        },
      }
    );
  };
  return (
    <div className="flex flex-col items-center justify-center h-screen">
      <div className="w-full max-w-md space-y-6">
        <div className="flex flex-col items-center justify-center space-y-2">
          <h1 className="text-2xl font-bold">Reset Password</h1>
          <p className="text-muted-foreground">Enter your password below</p>
        </div>
        <Card>
          <CardHeader>
            <Link to="/sign-in" className="flex items-center gap-2">
              <ArrowLeft className="w-4 h-4" />
              <span>Back to sign in</span>
            </Link>
          </CardHeader>
          <CardContent>
            {isSuccess ? (
              <div className="flex flex-col items-center justify-center">
                <CheckCircle className="w-10 h-10 text-green-500" />
                <h1 className="text-2xl font-bold">
                  Password reset successful
                </h1>
              </div>
            ) : (
              <Form {...form}>
                <form
                  onSubmit={form.handleSubmit(onSubmit)}
                  className="space-y-6"
                >
                  <FormField
                    name="newPassword"
                    control={form.control}
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>New Password</FormLabel>
                        <FormControl>
                          <Input {...field} placeholder="Enter your email" />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                  <FormField
                    name="confirmPassword"
                    control={form.control}
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>New Password</FormLabel>
                        <FormControl>
                          <Input {...field} placeholder="Enter your email" />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                  <Button type="submit" className="w-full" disabled={isPending}>
                    {isPending ? (
                      <Loader2 className="w-4 h-4 animate-spin" />
                    ) : (
                      "Reset Password"
                    )}
                  </Button>
                </form>
              </Form>
            )}
          </CardContent>
        </Card>
      </div>
    </div>
  );
};
export default ResetPassword;


frontend/app/routs/auth/sign-in.tsx
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { useLoginMutation } from "@/hooks/use-auth";
import { signInSchema } from "@/lib/schema";
import { useAuth } from "@/provider/auth-context";
import { zodResolver } from "@hookform/resolvers/zod";
import { Loader2 } from "lucide-react";
import { useForm } from "react-hook-form";
import { Link, useNavigate } from "react-router";
import { toast } from "sonner";
import { z } from "zod";
type SigninFormData = z.infer<typeof signInSchema>;
const SignIn = () => {
  const navigate = useNavigate();
  const { login } = useAuth();
  const form = useForm<SigninFormData>({
    resolver: zodResolver(signInSchema),
    defaultValues: {
      email: "",
      password: "",
    },
  });
  const { mutate, isPending } = useLoginMutation();
  const handleOnSubmit = (values: SigninFormData) => {
    mutate(values, {
      onSuccess: (data) => {
        login(data);
        console.log(data);
        toast.success("Login successful");
        navigate("/dashboard");
      },
      onError: (error: any) => {
        const errorMessage =
          error.response?.data?.message || "An error occurred";
        console.log(error);
        toast.error(errorMessage);
      },
    });
  };
  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-muted/40 p-4">
      <Card className="max-w-md w-full shadow-xl">
        <CardHeader className="text-center mb-5">
          <CardTitle className="text-2xl font-bold">Welcome back</CardTitle>
          <CardDescription className="text-sm text-muted-foreground">
            Sign in to your account to continue
          </CardDescription>
        </CardHeader>
        <CardContent>
          <Form {...form}>
            <form
              onSubmit={form.handleSubmit(handleOnSubmit)}
              className="space-y-6"
            >
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Email Address</FormLabel>
                    <FormControl>
                      <Input
                        type="email"
                        placeholder="email@example.com"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <div className="flex items-center justify-between">
                      <FormLabel>Password</FormLabel>
                      <Link
                        to="/forgot-password"
                        className="text-sm text-blue-600"
                      >
                        Forgot password?
                      </Link>
                    </div>
                    <FormControl>
                      <Input
                        type="password"
                        placeholder="********"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit" className="w-full" disabled={isPending}>
                {isPending ? <Loader2 className="w-4 h-4 mr-2" /> : "Sign in"}
              </Button>
            </form>
          </Form>
          <CardFooter className="flex items-center justify-center mt-6">
            <div className="flex items-center justify-center">
              <p className="text-sm text-muted-foreground">
                Don&apos;t have an account? <Link to="/sign-up">Sign up</Link>
              </p>
            </div>
          </CardFooter>
        </CardContent>
      </Card>
    </div>
  );
};
export default SignIn;

frontend/app/routs/auth/sign-up.tsx
import { signInSchema, signUpSchema } from "@/lib/schema";
import React from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Link, useNavigate } from "react-router";
import { useSignUpMutation } from "@/hooks/use-auth";
import { toast } from "sonner";
export type SignupFormData = z.infer<typeof signUpSchema>;
const SignUp = () => {
  const navigate = useNavigate();
  const form = useForm<SignupFormData>({
    resolver: zodResolver(signUpSchema),
    defaultValues: {
      email: "",
      password: "",
      name: "",
      confirmPassword: "",
    },
  });
  const { mutate, isPending } = useSignUpMutation();
  const handleOnSubmit = (values: SignupFormData) => {
    mutate(values, {
      onSuccess: () => {
        toast.success("Email Verification Required", {
          description:
            "Please check your email for a verification link. If you don't see it, please check your spam folder.",
        });
        form.reset();
        navigate("/sign-in");
      },
      onError: (error: any) => {
        const errorMessage =
          error.response?.data?.message || "An error occurred";
        console.log(error);
        toast.error(errorMessage);
      },
    });
  };
  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-muted/40 p-4">
      <Card className="max-w-md w-full shadow-xl">
        <CardHeader className="text-center mb-5">
          <CardTitle className="text-2xl font-bold">
            Create an account
          </CardTitle>
          <CardDescription className="text-sm text-muted-foreground">
            Create an account to continue
          </CardDescription>
        </CardHeader>
        <CardContent>
          <Form {...form}>
            <form
              onSubmit={form.handleSubmit(handleOnSubmit)}
              className="space-y-6"
            >
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Email Address</FormLabel>
                    <FormControl>
                      <Input
                        type="email"
                        placeholder="email@example.com"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="name"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Full Name</FormLabel>
                    <FormControl>
                      <Input type="text" placeholder="John Doe" {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Password</FormLabel>
                    <FormControl>
                      <Input
                        type="password"
                        placeholder="********"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <FormField
                control={form.control}
                name="confirmPassword"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Confirm Password</FormLabel>
                    <FormControl>
                      <Input
                        type="password"
                        placeholder="********"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <Button type="submit" className="w-full" disabled={isPending}>
                {isPending ? "Signing up..." : "Sign up"}
              </Button>
            </form>
          </Form>
          <CardFooter className="flex items-center justify-center mt-6">
            <div className="flex items-center justify-center">
              <p className="text-sm text-muted-foreground">
                Already have an account? <Link to="/sign-in">Sign in</Link>
              </p>
            </div>
          </CardFooter>
        </CardContent>
      </Card>
    </div>
  );
};
export default SignUp;

frontend/app/routs/auth/verify-email.tsx

import { Card, CardContent, CardHeader } from "@/components/ui/card";
import React, { useEffect, useState } from "react";
import { Link, useSearchParams } from "react-router";
import { ArrowLeft, CheckCircle, Loader, XCircle } from "lucide-react";
import { Button } from "@/components/ui/button";
import { useVerifyEmailMutation } from "@/hooks/use-auth";
import { toast } from "sonner";
const VerifyEmail = () => {
  const [searchParams] = useSearchParams();
  const token = searchParams.get("token");
  const [isSuccess, setIsSuccess] = useState(false);
  const { mutate, isPending: isVerifying } = useVerifyEmailMutation();
  useEffect(() => {
    if (token) {
      mutate(
        { token },
        {
          onSuccess: () => {
            setIsSuccess(true);
          },
          onError: (error: any) => {
            const errorMessage =
              error.response?.data?.message || "An error occurred";
            setIsSuccess(false);
            console.log(error);
            toast.error(errorMessage);
          },
        }
      );
    }
  }, [searchParams]);
  return (
    <div className="flex flex-col items-center justify-center h-screen">
      <h1 className="text-2xl font-bold">Verify Email</h1>
      <p className="text-sm text-gray-500">Verifying your email...</p>
      <Card className="w-full max-w-md">
        {/* <CardHeader>
          <Link to="/sign-in" className="flex items-center gap-2 text-sm">
            <ArrowLeft className="w-4 h-4 mr-2" />
            Back to Sign in
          </Link>
        </CardHeader> */}
        <CardContent>
          <div className="flex flex-col items-center justify-center py-6 ">
            {isVerifying ? (
              <>
                <Loader className="w-10 h-10 text-gray-500 animate-spin" />
                <h3 className="text-lg font-semibold">Verifying email...</h3>
                <p className="text-sm text-gray-500">
                  Please wait while we verify your email.
                </p>
              </>
            ) : isSuccess ? (
              <>
                <CheckCircle className="w-10 h-10 text-green-500" />
                <h3 className="text-lg font-semibold">Email Verified</h3>
                <p className="text-sm text-gray-500">
                  Your email has been verified successfully.
                </p>
                <Link to="/sign-in" className="text-sm text-blue-500 mt-6">
                  <Button variant="outline">Back to Sign in</Button>
                </Link>
              </>
            ) : (
              <>
                <XCircle className="w-10 h-10 text-red-500" />
                <h3 className="text-lg font-semibold">
                  Email Verification Failed
                </h3>
                <p className="text-sm text-gray-500">
                  Your email verification failed. Please try again.
                </p>
                <Link to="/sign-in" className="text-sm text-blue-500 mt-6">
                  <Button variant="outline">Back to Sign in</Button>
                </Link>
              </>
            )}
          </div>
        </CardContent>
      </Card>
    </div>
  );
};
export default VerifyEmail;

frontend/app/routs/user/profile.tsx
import { BackButton } from "@/components/back-button";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Separator } from "@/components/ui/separator";
import {
  useChangePassword,
  useUpdateUserProfile,
  useUserProfileQuery,
} from "@/hooks/use-user";
import { useAuth } from "@/provider/auth-context";
import type { User } from "@/types";
import { zodResolver } from "@hookform/resolvers/zod";
import { AlertCircle, Loader, Loader2 } from "lucide-react";
import { useForm } from "react-hook-form";
import { useNavigate } from "react-router";
import { toast } from "sonner";
import { z } from "zod";
const changePasswordSchema = z
  .object({
    currentPassword: z
      .string()
      .min(1, { message: "Current password is required" }),
    newPassword: z.string().min(8, { message: "New password is required" }),
    confirmPassword: z
      .string()
      .min(8, { message: "Confirm password is required" }),
  })
  .refine((data) => data.newPassword === data.confirmPassword, {
    message: "Passwords do not match",
    path: ["confirmPassword"],
  });
const profileSchema = z.object({
  name: z.string().min(1, { message: "Name is required" }),
  profilePicture: z.string().optional(),
});
export type ChangePasswordFormData = z.infer<typeof changePasswordSchema>;
export type ProfileFormData = z.infer<typeof profileSchema>;
const Profile = () => {
  const { data: user, isPending } = useUserProfileQuery() as {
    data: User;
    isPending: boolean;
  };
  const { logout } = useAuth();
  const navigate = useNavigate();
  const form = useForm<ChangePasswordFormData>({
    resolver: zodResolver(changePasswordSchema),
    defaultValues: {
      currentPassword: "",
      newPassword: "",
      confirmPassword: "",
    },
  });
  const profileForm = useForm<ProfileFormData>({
    resolver: zodResolver(profileSchema),
    defaultValues: {
      name: user?.name || "",
      profilePicture: user?.profilePicture || "",
    },
    values: {
      name: user?.name || "",
      profilePicture: user?.profilePicture || "",
    },
  });
  const { mutate: updateUserProfile, isPending: isUpdatingProfile } =
    useUpdateUserProfile();
  const {
    mutate: changePassword,
    isPending: isChangingPassword,
    error,
  } = useChangePassword();
  const handlePasswordChange = (values: ChangePasswordFormData) => {
    changePassword(values, {
      onSuccess: () => {
        toast.success(
          "Password updated successfully. You will be logged out. Please login again."
        );
        form.reset();
        setTimeout(() => {
          logout();
          navigate("/sign-in");
        }, 3000);
      },
      onError: (error: any) => {
        const errorMessage =
          error.response?.data?.error || "Failed to update password";
        toast.error(errorMessage);
        console.log(error);
      },
    });
  };
  const handleProfileFormSubmit = (values: ProfileFormData) => {
    updateUserProfile(
      { name: values.name, profilePicture: values.profilePicture || "" },
      {
        onSuccess: () => {
          toast.success("Profile updated successfully");
        },
        onError: (error: any) => {
          const errorMessage =
            error.response?.data?.error || "Failed to update profile";
          toast.error(errorMessage);
          console.log(error);
        },
      }
    );
  };
  if (isPending)
    return (
      <div className="flex justify-center items-center h-screen">
        <Loader className="animate-spin" />
      </div>
    );
  return (
    <div className="space-y-8">
      <div className="px-4 md:px-0">
        <BackButton />
        <h3 className="text-lg font-medium">Profile Information</h3>
        <p className="text-sm text-muted-foreground">
          Manage your account settings and preferences.
        </p>
      </div>
      <Separator />
      <Card>
        <CardHeader>
          <CardTitle>Personal Information</CardTitle>
          <CardDescription>Update your personal details.</CardDescription>
        </CardHeader>
        <CardContent>
          <Form {...profileForm}>
            <form
              onSubmit={profileForm.handleSubmit(handleProfileFormSubmit)}
              className="grid gap-4"
            >
              <div className="flex items-center space-x-4 mb-6">
                <Avatar className="h-20 w-20 bg-gray-600">
                  <AvatarImage
                    src={
                      profileForm.watch("profilePicture") ||
                      user?.profilePicture
                    }
                    alt={user?.name}
                  />
                  <AvatarFallback className="text-xl">
                    {user?.name?.charAt(0) || "U"}
                  </AvatarFallback>
                </Avatar>
                <div>
                  <input
                    id="avatar-upload"
                    type="file"
                    accept="image/*"
                    // onChange={handleAvatarChange}
                    // disabled={uploading || isUpdatingProfile}
                    style={{ display: "none" }}
                  />
                  <Button
                    type="button"
                    size="sm"
                    variant="outline"
                    onClick={() =>
                      document.getElementById("avatar-upload")?.click()
                    }
                    // disabled={uploading || isUpdatingProfile}
                  >
                    Change Avatar
                  </Button>
                </div>
              </div>
              <FormField
                control={profileForm.control}
                name="name"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Full Name</FormLabel>
                    <FormControl>
                      <Input {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              <div className="grid gap-2">
                <Label htmlFor="email">Email Address</Label>
                <Input
                  id="email"
                  type="email"
                  defaultValue={user?.email}
                  disabled
                />
                <p className="text-xs text-muted-foreground">
                  Your email address cannot be changed.
                </p>
              </div>
              <Button
                type="submit"
                className="w-fit"
                disabled={isUpdatingProfile || isPending}
              >
                {isUpdatingProfile ? (
                  <>
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    Saving...
                  </>
                ) : (
                  "Save Changes"
                )}
              </Button>
            </form>
          </Form>
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <CardTitle>Security</CardTitle>
          <CardDescription>Update your password.</CardDescription>
        </CardHeader>
        <CardContent>
          <Form {...form}>
            <form
              onSubmit={form.handleSubmit(handlePasswordChange)}
              className="grid gap-4"
            >
              {error && (
                <Alert variant="destructive">
                  <AlertCircle className="h-4 w-4" />
                  <AlertDescription>{error.message}</AlertDescription>
                </Alert>
              )}
              <div className="grid gap-2">
                <FormField
                  control={form.control}
                  name="currentPassword"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Current Password</FormLabel>
                      <FormControl>
                        <Input
                          id="current-password"
                          type="password"
                          placeholder="********"
                          {...field}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
                <FormField
                  control={form.control}
                  name="newPassword"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>New Password</FormLabel>
                      <FormControl>
                        <Input
                          id="new-password"
                          type="password"
                          placeholder="********"
                          {...field}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
                <FormField
                  control={form.control}
                  name="confirmPassword"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Confirm Password</FormLabel>
                      <FormControl>
                        <Input
                          id="confirm-password"
                          placeholder="********"
                          type="password"
                          {...field}
                        />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              </div>
              <Button
                type="submit"
                className="mt-2 w-fit"
                disabled={isPending || isChangingPassword}
              >
                {isPending || isChangingPassword ? (
                  <>
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    Updating...
                  </>
                ) : (
                  "Update Password"
                )}
              </Button>
            </form>
          </Form>
        </CardContent>
      </Card>
    </div>
  );
};
export default Profile;
 

frontend/app/routs/user/user-layout.tsx


import { Outlet } from "react-router";
const UserLayout = () => {
  return (
    <div className="container max-w-3xl mx-auto py-8 md:py-16">
      <Outlet />
    </div>
  );
};
export default UserLayout;

frontend/app/routs.ts

import {
  type RouteConfig,
  index,
  layout,
  route,
} from "@react-router/dev/routes";
export default [
  layout("routes/auth/auth-layout.tsx", [
    index("routes/root/home.tsx"),
    route("sign-in", "routes/auth/sign-in.tsx"),
    route("sign-up", "routes/auth/sign-up.tsx"),
    route("forgot-password", "routes/auth/forgot-password.tsx"),
    route("reset-password", "routes/auth/reset-password.tsx"),
    route("verify-email", "routes/auth/verify-email.tsx"),
  ]),
  layout("routes/dashboard/dashboard-layout.tsx", [
    route("dashboard", "routes/dashboard/index.tsx"),
    route("emails", "routes/emails/index.tsx"),
    route("projects", "routes/projects/index.tsx"),
    route("projects/:projectId", "routes/projects/$projectId.tsx"),
    route("stages", "routes/stages/index.tsx"),
  ]),
  layout("routes/user/user-layout.tsx", [
    route("user/profile", "routes/user/profile.tsx"),
  ]),
] satisfies RouteConfig;




backend/controllers/auth-controller.js
import User from "../models/user.js";
import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";
import Verification from "../models/verification.js";
import { sendEmail } from "../libs/send-email.js";
import aj from "../libs/arcjet.js";
const registerUser = async (req, res) => {
  try {
    const { email, name, password } = req.body;
    const decision = await aj.protect(req, { email });
    console.log("Arcjet decision", decision.isDenied());
    if (decision.isDenied()) {
      res.writeHead(403, { "Content-Type": "application/json" });
      res.end(JSON.stringify({ message: "Invalid email address" }));
    }
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({
        message: "Email address already in use",
      });
    }
    const salt = await bcrypt.genSalt(10);
    const hashPassword = await bcrypt.hash(password, salt);
    const newUser = await User.create({
      email,
      password: hashPassword,
      name,
    });
    const verificationToken = jwt.sign(
      { userId: newUser._id, purpose: "email-verification" },
      process.env.JWT_SECRET,
      { expiresIn: "1h" }
    );
    await Verification.create({
      userId: newUser._id,
      token: verificationToken,
      expiresAt: new Date(Date.now() + 1 * 60 * 60 * 1000),
    });
    // send email
    const verificationLink = `${process.env.FRONTEND_URL}/verify-email?token=${verificationToken}`;
    const emailBody = `<p>Click <a href="${verificationLink}">here</a> to verify your email</p>`;
    const emailSubject = "Verify your email";
    const isEmailSent = await sendEmail(email, emailSubject, emailBody);
    if (!isEmailSent) {
      return res.status(500).json({
        message: "Failed to send verification email",
      });
    }
    res.status(201).json({
      message:
        "Verification email sent to your email. Please check and verify your account.",
    });
  } catch (error) {
    console.log(error);
    res.status(500).json({ message: "Internal server error" });
  }
};
const loginUser = async (req, res) => {
  try {
    const { email, password } = req.body;
    const user = await User.findOne({ email }).select("+password");
    if (!user) {
      return res.status(400).json({ message: "Invalid email or password" });
    }
    if (!user.isEmailVerified) {
      const existingVerification = await Verification.findOne({
        userId: user._id,
      });
      if (existingVerification && existingVerification.expiresAt > new Date()) {
        return res.status(400).json({
          message:
            "Email not verified. Please check your email for the verification link.",
        });
      } else {
        await Verification.findByIdAndDelete(existingVerification._id);
        const verificationToken = jwt.sign(
          { userId: user._id, purpose: "email-verification" },
          process.env.JWT_SECRET,
          { expiresIn: "1h" }
        );
        await Verification.create({
          userId: user._id,
          token: verificationToken,
          expiresAt: new Date(Date.now() + 1 * 60 * 60 * 1000),
        });
        // send email
        const verificationLink = `${process.env.FRONTEND_URL}/verify-email?token=${verificationToken}`;
        const emailBody = `<p>Click <a href="${verificationLink}">here</a> to verify your email</p>`;
        const emailSubject = "Verify your email";
        const isEmailSent = await sendEmail(email, emailSubject, emailBody);
        if (!isEmailSent) {
          return res.status(500).json({
            message: "Failed to send verification email",
          });
        }
        res.status(201).json({
          message:
            "Verification email sent to your email. Please check and verify your account.",
        });
      }
    }
    const isPasswordValid = await bcrypt.compare(password, user.password);
    if (!isPasswordValid) {
      return res.status(400).json({ message: "Invalid email or password" });
    }
    const token = jwt.sign(
      { userId: user._id, purpose: "login" },
      process.env.JWT_SECRET,
      { expiresIn: "7d" }
    );
    user.lastLogin = new Date();
    await user.save();
    const userData = user.toObject();
    delete userData.password;
    res.status(200).json({
      message: "Login successful",
      token,
      user: userData,
    });
  } catch (error) {
    console.log(error);
    res.status(500).json({ message: "Internal server error" });
  }
};
const verifyEmail = async (req, res) => {
  try {
    const { token } = req.body;
    const payload = jwt.verify(token, process.env.JWT_SECRET);
    if (!payload) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    const { userId, purpose } = payload;
    if (purpose !== "email-verification") {
      return res.status(401).json({ message: "Unauthorized" });
    }
    const verification = await Verification.findOne({
      userId,
      token,
    });
    if (!verification) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    const isTokenExpired = verification.expiresAt < new Date();
    if (isTokenExpired) {
      return res.status(401).json({ message: "Token expired" });
    }
    const user = await User.findById(userId);
    if (!user) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    if (user.isEmailVerified) {
      return res.status(400).json({ message: "Email already verified" });
    }
    user.isEmailVerified = true;
    await user.save();
    await Verification.findByIdAndDelete(verification._id);
    res.status(200).json({ message: "Email verified successfully" });
  } catch (error) {
    console.log(error);
    res.status(500).json({ message: "Internal server error" });
  }
};
const resetPasswordRequest = async (req, res) => {
  try {
    const { email } = req.body;
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(400).json({ message: "User not found" });
    }
    if (!user.isEmailVerified) {
      return res
        .status(400)
        .json({ message: "Please verify your email first" });
    }
    const existingVerification = await Verification.findOne({
      userId: user._id,
    });
    if (existingVerification && existingVerification.expiresAt > new Date()) {
      return res.status(400).json({
        message: "Reset password request already sent",
      });
    }
    if (existingVerification && existingVerification.expiresAt < new Date()) {
      await Verification.findByIdAndDelete(existingVerification._id);
    }
    const resetPasswordToken = jwt.sign(
      { userId: user._id, purpose: "reset-password" },
      process.env.JWT_SECRET,
      { expiresIn: "15m" }
    );
    await Verification.create({
      userId: user._id,
      token: resetPasswordToken,
      expiresAt: new Date(Date.now() + 15 * 60 * 1000),
    });
    const resetPasswordLink = `${process.env.FRONTEND_URL}/reset-password?token=${resetPasswordToken}`;
    const emailBody = `<p>Click <a href="${resetPasswordLink}">here</a> to reset your password</p>`;
    const emailSubject = "Reset your password";
    const isEmailSent = await sendEmail(email, emailSubject, emailBody);
    if (!isEmailSent) {
      return res.status(500).json({
        message: "Failed to send reset password email",
      });
    }
    res.status(200).json({ message: "Reset password email sent" });
  } catch (error) {
    console.log(error);
    res.status(500).json({ message: "Internal server error" });
  }
};
const verifyResetPasswordTokenAndResetPassword = async (req, res) => {
  try {
    const { token, newPassword, confirmPassword } = req.body;
    const payload = jwt.verify(token, process.env.JWT_SECRET);
    if (!payload) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    const { userId, purpose } = payload;
    if (purpose !== "reset-password") {
      return res.status(401).json({ message: "Unauthorized" });
    }
    const verification = await Verification.findOne({
      userId,
      token,
    });
    if (!verification) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    const isTokenExpired = verification.expiresAt < new Date();
    if (isTokenExpired) {
      return res.status(401).json({ message: "Token expired" });
    }
    const user = await User.findById(userId);
    if (!user) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    if (newPassword !== confirmPassword) {
      return res.status(400).json({ message: "Passwords do not match" });
    }
    const salt = await bcrypt.genSalt(10);
    const hashPassword = await bcrypt.hash(newPassword, salt);
    user.password = hashPassword;
    await user.save();
    await Verification.findByIdAndDelete(verification._id);
    res.status(200).json({ message: "Password reset successfully" });
  } catch (error) {
    console.log(error);
    res.status(500).json({ message: "Internal server error" });
  }
};
export {
  registerUser,
  loginUser,
  verifyEmail,
  resetPasswordRequest,
  verifyResetPasswordTokenAndResetPassword,
};

backend/controllers/user.js
import User from "../models/user.js";
import bcrypt from "bcrypt";
const getUserProfile = async (req, res) => {
  try {
    const user = await User.findById(req.user._id).select("-password");
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }
    delete user.password;
    // jfkd
    res.status(200).json(user);
  } catch (error) {
    console.error("Error fetching user profile:", error);
    res.status(500).json({ message: "Server error" });
  }
};
const updateUserProfile = async (req, res) => {
  try {
    const { name, profilePicture } = req.body;
    const user = await User.findById(req.user._id);
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }
    user.name = name;
    user.profilePicture = profilePicture;
    await user.save();
    res.status(200).json(user);
  } catch (error) {
    console.error("Error updating user profile:", error);
    res.status(500).json({ message: "Server error" });
  }
};
const changePassword = async (req, res) => {
  try {
    const { currentPassword, newPassword, confirmPassword } = req.body;
    const user = await User.findById(req.user._id).select("+password");
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }
    if (newPassword !== confirmPassword) {
      return res
        .status(400)
        .json({ message: "New password and confirm password do not match" });
    }
    const isPasswordValid = await bcrypt.compare(
      currentPassword,
      user.password
    );
    if (!isPasswordValid) {
      return res.status(403).json({ message: "Invalid old password" });
    }
    const hashedPassword = await bcrypt.hash(newPassword, 10);
    user.password = hashedPassword;
    await user.save();
    res.status(200).json({ message: "Password updated successfully" });
  } catch (error) {
    console.error("Error changing password:", error);
    res.status(500).json({ message: "Server error" });
  }
};
export { getUserProfile, updateUserProfile, changePassword };


backend/libs/send-email.js

import nodemailer from 'nodemailer';
import dotenv from 'dotenv';
dotenv.config();
const transporter = nodemailer.createTransport({
  service: 'gmail',
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASS,
  },
});
export const sendEmail = async (to, subject, html) => {
  const mailOptions = {
    from: `TaskHub <${process.env.EMAIL_USER}>`,
    to,
    subject,
    html,
  };
  try {
    const info = await transporter.sendMail(mailOptions);
    console.log(' Email sent:', info.response);
    return true;
  } catch (error) {
    console.error(' Error sending email:', error);
    return false;
  }
};

backend/libs/validate-schema.js

import { z } from "zod";
const registerSchema = z.object({
  name: z.string().min(3, "Name is required"),
  email: z.string().email("Invalid email address"),
  password: z.string().min(8, "Password must be at least 8 characters long"),
});
const loginSchema = z.object({
  email: z.string().email("Invalid email address"),
  password: z.string().min(1, "Password is required"),
});
const verifyEmailSchema = z.object({
  token: z.string().min(1, "Token is required"),
});
const resetPasswordSchema = z.object({
  token: z.string().min(1, "Token is required"),
  newPassword: z.string().min(8, "Password must be at least 8 characters long"),
  confirmPassword: z.string().min(1, "Confirm password is required"),
});
const emailSchema = z.object({
  email: z.string().email("Invalid email address"),
});
const inviteMemberSchema = z.object({
  email: z.string().email("Invalid email address"),
  role: z.enum(["admin", "member", "viewer"]),
});
const tokenSchema = z.object({
  token: z.string().min(1, "Token is required"),
});
const workspaceSchema = z.object({
  name: z.string().min(1, "Name is required"),
  description: z.string().optional(),
  color: z.string().min(1, "Color is required"),
});

const taskSchema = z.object({
  title: z.string().min(1, "Task title is required"),
  description: z.string().optional(),
  status: z.enum(["To Do", "In Progress", "Done"]),
  priority: z.enum(["Low", "Medium", "High"]),
  dueDate: z.string().min(1, "Due date is required"),
  assignees: z.array(z.string()).min(1, "At least one assignee is required"),
});

// Project schemas
export const projectSchema = z.object({
  project_name: z.string().min(3).max(255),
  description: z.string().max(1000).optional(),
  status: z.enum(["Pending", "Ongoing", "Completed", "Archived"]).default("Pending"),
  created_at: z.string().regex(/^\d{4}-\d{2}-\d{2}$/),
  user_id: z.number().positive(),
});
export const projectIdSchema = z.object({
  id: z.string().transform((val) => parseInt(val, 10)),
});
export const updateProjectSchema = z.object({
  project_name: z.string().min(3).max(255).optional(),
  description: z.string().max(1000).optional(),
  status: z.enum(["Pending", "Ongoing", "Completed", "Archived"]).optional(),
  created_at: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
}).refine((data) => Object.keys(data).length > 0, {
  message: "At least one field must be provided for update",
});
// ... other existing schemas (workspaceSchema, inviteMemberSchema, etc.)
export {
  registerSchema,
  loginSchema,
  verifyEmailSchema,
  resetPasswordSchema,
  emailSchema,
  workspaceSchema,
  // projectSchema,
  // projectIdSchema ,
  // updateProjectSchema ,
  taskSchema,
  inviteMemberSchema,
  tokenSchema,
};

backend/libs/arcjet.js

import arcjet, {
  detectBot,
  shield,
  tokenBucket,
  validateEmail,
} from "@arcjet/node";
const aj = arcjet({
  // Get your site key from https://app.arcjet.com and set it as an environment
  // variable rather than hard coding.
  key: process.env.ARCJET_KEY,
  characteristics: ["ip.src"], // Track requests by IP
  rules: [
    // Shield protects your app from common attacks e.g. SQL injection
    shield({ mode: "LIVE" }),
    // Create a bot detection rule
    detectBot({
      mode: "LIVE", // Blocks requests. Use "DRY_RUN" to log only
      // Block all bots except the following
      allow: [
        "CATEGORY:SEARCH_ENGINE", // Google, Bing, etc
        // Uncomment to allow these other common bot categories
        // See the full list at https://arcjet.com/bot-list
        //"CATEGORY:MONITOR", // Uptime monitoring services
        //"CATEGORY:PREVIEW", // Link previews e.g. Slack, Discord
      ],
    }),
    validateEmail({
      mode: "LIVE", // will block requests. Use "DRY_RUN" to log only
      // block disposable, invalid, and email addresses with no MX records
      deny: ["DISPOSABLE", "INVALID", "NO_MX_RECORDS"],
    }),
    // Create a token bucket rate limit. Other algorithms are supported.
    tokenBucket({
      mode: "LIVE",
      refillRate: 5, // Refill 5 tokens per interval
      interval: 10, // Refill every 10 seconds
      capacity: 10, // Bucket capacity of 10 tokens
    }),
  ],
});
export default aj;


backend/libs/index.js
const mongoose = require('mongoose');
require('dotenv').config();
const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
    console.log('MongoDB connected successfully');
  } catch (err) {
    console.error('MongoDB connection error:', err);
    process.exit(1);
  }
};
module.exports = { connectDB };


backend/middleware/auth-middlaeware.js

import jwt from "jsonwebtoken";
import User from "../models/user.js";
const authMiddleware = async (req, res, next) => {
  try {
    const token = req.headers.authorization.split(" ")[1]; //Bearer dhghjhdkjfg
    if (!token) {
      return res.status(401).json({
        message: "Unauthorized",
      });
    }
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const user = await User.findById(decoded.userId);
    if (!user) {
      return res.status(401).json({
        message: "Unauthorized",
      });
    }
    req.user = user;
    next();
  } catch (error) {
    console.log(error);
    res.status(500).json({
      message: "Internal server error",
    });
  }
};
export default authMiddleware;


backend/models/user.js

import mongoose, { Schema } from "mongoose";
const userSchema = new Schema(
  {
    email: {
      type: String,
      required: true,
      unique: true,
      trim: true,
      lowercase: true,
    },
    password: { type: String, required: true, select: false },
    name: { type: String, required: true, trim: true },
    profilePicture: { type: String },
    isEmailVerified: { type: Boolean, default: false },
    lastLogin: { type: Date },
    is2FAEnabled: { type: Boolean, default: false },
    twoFAOtp: { type: String, select: false },
    twoFAOtpExpires: { type: Date, select: false },
  },
  { timestamps: true }
);
const User = mongoose.model("User", userSchema);
export default User;

backend/models/verification.js
 import mongoose from "mongoose";
const verificationSchema = new mongoose.Schema(
  {
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    token: {
      type: String,
      required: true,
    },
    expiresAt: {
      type: Date,
      required: true,
    },
  },
  { timestamps: true }
);
const Verification = mongoose.model("Verification", verificationSchema);
export default Verification;

backend/routs/auth.js

import express from "express";
import { z } from "zod";
import { validateRequest } from "zod-express-middleware";
import {
  emailSchema,
  loginSchema,
  registerSchema,
  resetPasswordSchema,
  verifyEmailSchema,
} from "../libs/validate-schema.js";
import {
  loginUser,
  registerUser,
  resetPasswordRequest,
  verifyEmail,
  verifyResetPasswordTokenAndResetPassword,
} from "../controllers/auth-controller.js";
const router = express.Router();
router.post(
  "/register",
  validateRequest({
    body: registerSchema,
  }),
  registerUser
);
router.post(
  "/login",
  validateRequest({
    body: loginSchema,
  }),
  loginUser
);
router.post(
  "/verify-email",
  validateRequest({
    body: verifyEmailSchema,
  }),
  verifyEmail
);
router.post(
  "/reset-password-request",
  validateRequest({
    body: emailSchema,
  }),
  resetPasswordRequest
);
router.post(
  "/reset-password",
  validateRequest({
    body: resetPasswordSchema,
  }),
  verifyResetPasswordTokenAndResetPassword
);
export default router;

backend/routs/user.js
import express from "express";
import authenticateUser from "../middleware/auth-middleware.js";
import {
  changePassword,
  getUserProfile,
  updateUserProfile,
} from "../controllers/user.js";
import { z } from "zod";
import { validateRequest } from "zod-express-middleware";
const router = express.Router();
router.get("/profile", authenticateUser, getUserProfile);
router.put(
  "/profile",
  authenticateUser,
  validateRequest({
    body: z.object({
      name: z.string(),
      profilePicture: z.string().optional(),
    }),
  }),
  updateUserProfile
);
router.put(
  "/change-password",
  authenticateUser,
  validateRequest({
    body: z.object({
      currentPassword: z.string(),
      newPassword: z.string(),
      confirmPassword: z.string(),
    }),
  }),
  changePassword
);
export default router;


backend/index.js

// backend/index.js
import cors from "cors";
import dotenv from "dotenv";
import express from "express";
import mongoose from "mongoose";
import morgan from "morgan";
import routes from "./routes/index.js";
dotenv.config();
const app = express();
const corsOptions = {
  origin: process.env.FRONTEND_URL || "http://localhost:5173",
  methods: ["GET", "POST", "DELETE", "PUT", "OPTIONS"],
  credentials: true,
  allowedHeaders: ["Content-Type", "Authorization"],
};
app.use(cors(corsOptions));
app.options("*", cors(corsOptions)); // <-- Handle preflight
app.use(morgan("dev"));
// db connection
mongoose
  .connect(process.env.MONGODB_URI)
  .then(() => console.log("DB Connected successfully."))
  .catch((err) => console.log("Failed to connect to DB:", err));
app.use(express.json());
const PORT = process.env.PORT || 5000;
app.get("/", async (req, res) => {
  res.status(200).json({
    message: "Welcome to TaskHub API",
  });
});
// http:localhost:500/api-v1/
app.use("/api-v1", routes);
// error middleware
app.use((err, req, res, next) => {
  console.log(err.stack);
  res.status(500).json({ message: "Internal server error" });
});
// not found middleware
app.use((req, res) => {
  res.status(404).json({
    message: "Not found",
  });
});
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
also keep this for further